Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    NEWLINE

Grammar

Rule 0     S' -> program
Rule 1     program -> funlist
Rule 2     funlist -> funlist function
Rule 3     funlist -> function
Rule 4     function -> FUN ID ( arglist ) localslist BEGIN statementBlock END
Rule 5     arglist -> args
Rule 6     arglist -> empty
Rule 7     args -> args , var_decl
Rule 8     args -> var_decl
Rule 9     localslist -> locals
Rule 10    localslist -> empty
Rule 11    locals -> locals declaration_local ;
Rule 12    locals -> declaration_local ;
Rule 13    declaration_local -> var_decl
Rule 14    declaration_local -> function
Rule 15    var_decl -> ID : type_specifier
Rule 16    type_specifier -> simple_type
Rule 17    type_specifier -> simple_type [ INTEGER ]
Rule 18    simple_type -> INT
Rule 19    simple_type -> FLOAT
Rule 20    statementBlock -> statementBlock ; statement
Rule 21    statementBlock -> statement
Rule 22    statement -> WHILE relation DO statement
Rule 23    statement -> ifthen
Rule 24    statement -> ifthenelse
Rule 25    statement -> location ASIGN expression
Rule 26    statement -> inOutExpr
Rule 27    statement -> RETURN expression
Rule 28    statement -> RETURN
Rule 29    statement -> functionCall
Rule 30    statement -> SKIP
Rule 31    statement -> BREAK
Rule 32    statement -> BEGIN statementBlock END
Rule 33    ifthen -> IF relation THEN statement
Rule 34    ifthenelse -> IF relation THEN statement ELSE statement
Rule 35    functionCall -> ID ( paramslistop )
Rule 36    paramslistop -> paramList
Rule 37    paramslistop -> empty
Rule 38    paramList -> paramList , expression
Rule 39    paramList -> expression
Rule 40    inOutExpr -> PRINT ( STRING )
Rule 41    inOutExpr -> WRITE ( expression )
Rule 42    inOutExpr -> READ ( location )
Rule 43    location -> ID
Rule 44    location -> ID [ expression ]
Rule 45    relation -> relation OR relation
Rule 46    relation -> relation AND relation
Rule 47    relation -> NOT relation
Rule 48    relation -> ( relation )
Rule 49    relation -> expression LT expression
Rule 50    relation -> expression LE expression
Rule 51    relation -> expression GT expression
Rule 52    relation -> expression GE expression
Rule 53    relation -> expression NE expression
Rule 54    relation -> expression EQUAL expression
Rule 55    relation -> TRUE
Rule 56    relation -> FALSE
Rule 57    expression -> expression + expression
Rule 58    expression -> expression - expression
Rule 59    expression -> expression * expression
Rule 60    expression -> expression / expression
Rule 61    expression -> - expression
Rule 62    expression -> + expression
Rule 63    expression -> ( expression )
Rule 64    expression -> ID
Rule 65    expression -> number
Rule 66    expression -> ID [ expression ]
Rule 67    expression -> casting
Rule 68    expression -> functionCall
Rule 69    casting -> INT ( expression )
Rule 70    casting -> FLOAT ( expression )
Rule 71    number -> INTEGER
Rule 72    number -> FLOATNUM
Rule 73    empty -> <empty>

Terminals, with rules where they appear

(                    : 4 35 40 41 42 48 63 69 70
)                    : 4 35 40 41 42 48 63 69 70
*                    : 59
+                    : 57 62
,                    : 7 38
-                    : 58 61
/                    : 60
:                    : 15
;                    : 11 12 20
AND                  : 46
ASIGN                : 25
BEGIN                : 4 32
BREAK                : 31
DO                   : 22
ELSE                 : 34
END                  : 4 32
EQUAL                : 54
FALSE                : 56
FLOAT                : 19 70
FLOATNUM             : 72
FUN                  : 4
GE                   : 52
GT                   : 51
ID                   : 4 15 35 43 44 64 66
IF                   : 33 34
INT                  : 18 69
INTEGER              : 17 71
LE                   : 50
LT                   : 49
NE                   : 53
NEWLINE              : 
NOT                  : 47
OR                   : 45
PRINT                : 40
READ                 : 42
RETURN               : 27 28
SKIP                 : 30
STRING               : 40
THEN                 : 33 34
TRUE                 : 55
WHILE                : 22
WRITE                : 41
[                    : 17 44 66
]                    : 17 44 66
error                : 

Nonterminals, with rules where they appear

arglist              : 4
args                 : 5 7
casting              : 67
declaration_local    : 11 12
empty                : 6 10 37
expression           : 25 27 38 39 41 44 49 49 50 50 51 51 52 52 53 53 54 54 57 57 58 58 59 59 60 60 61 62 63 66 69 70
function             : 2 3 14
functionCall         : 29 68
funlist              : 1 2
ifthen               : 23
ifthenelse           : 24
inOutExpr            : 26
locals               : 9 11
localslist           : 4
location             : 25 42
number               : 65
paramList            : 36 38
paramslistop         : 35
program              : 0
relation             : 22 33 34 45 45 46 46 47 48
simple_type          : 16 17
statement            : 20 21 22 33 34 34
statementBlock       : 4 20 32
type_specifier       : 15
var_decl             : 7 8 13

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . funlist
    (2) funlist -> . funlist function
    (3) funlist -> . function
    (4) function -> . FUN ID ( arglist ) localslist BEGIN statementBlock END

    FUN             shift and go to state 4

    function                       shift and go to state 1
    funlist                        shift and go to state 2
    program                        shift and go to state 3

state 1

    (3) funlist -> function .

    FUN             reduce using rule 3 (funlist -> function .)
    $end            reduce using rule 3 (funlist -> function .)


state 2

    (1) program -> funlist .
    (2) funlist -> funlist . function
    (4) function -> . FUN ID ( arglist ) localslist BEGIN statementBlock END

    $end            reduce using rule 1 (program -> funlist .)
    FUN             shift and go to state 4

    function                       shift and go to state 5

state 3

    (0) S' -> program .



state 4

    (4) function -> FUN . ID ( arglist ) localslist BEGIN statementBlock END

    ID              shift and go to state 6


state 5

    (2) funlist -> funlist function .

    FUN             reduce using rule 2 (funlist -> funlist function .)
    $end            reduce using rule 2 (funlist -> funlist function .)


state 6

    (4) function -> FUN ID . ( arglist ) localslist BEGIN statementBlock END

    (               shift and go to state 7


state 7

    (4) function -> FUN ID ( . arglist ) localslist BEGIN statementBlock END
    (5) arglist -> . args
    (6) arglist -> . empty
    (7) args -> . args , var_decl
    (8) args -> . var_decl
    (73) empty -> .
    (15) var_decl -> . ID : type_specifier

    )               reduce using rule 73 (empty -> .)
    ID              shift and go to state 11

    args                           shift and go to state 8
    var_decl                       shift and go to state 9
    arglist                        shift and go to state 10
    empty                          shift and go to state 12

state 8

    (5) arglist -> args .
    (7) args -> args . , var_decl

    )               reduce using rule 5 (arglist -> args .)
    ,               shift and go to state 13


state 9

    (8) args -> var_decl .

    ,               reduce using rule 8 (args -> var_decl .)
    )               reduce using rule 8 (args -> var_decl .)


state 10

    (4) function -> FUN ID ( arglist . ) localslist BEGIN statementBlock END

    )               shift and go to state 14


state 11

    (15) var_decl -> ID . : type_specifier

    :               shift and go to state 15


state 12

    (6) arglist -> empty .

    )               reduce using rule 6 (arglist -> empty .)


state 13

    (7) args -> args , . var_decl
    (15) var_decl -> . ID : type_specifier

    ID              shift and go to state 11

    var_decl                       shift and go to state 16

state 14

    (4) function -> FUN ID ( arglist ) . localslist BEGIN statementBlock END
    (9) localslist -> . locals
    (10) localslist -> . empty
    (11) locals -> . locals declaration_local ;
    (12) locals -> . declaration_local ;
    (73) empty -> .
    (13) declaration_local -> . var_decl
    (14) declaration_local -> . function
    (15) var_decl -> . ID : type_specifier
    (4) function -> . FUN ID ( arglist ) localslist BEGIN statementBlock END

    BEGIN           reduce using rule 73 (empty -> .)
    ID              shift and go to state 11
    FUN             shift and go to state 4

    function                       shift and go to state 17
    localslist                     shift and go to state 18
    declaration_local              shift and go to state 19
    var_decl                       shift and go to state 20
    locals                         shift and go to state 22
    empty                          shift and go to state 21

state 15

    (15) var_decl -> ID : . type_specifier
    (16) type_specifier -> . simple_type
    (17) type_specifier -> . simple_type [ INTEGER ]
    (18) simple_type -> . INT
    (19) simple_type -> . FLOAT

    INT             shift and go to state 25
    FLOAT           shift and go to state 26

    type_specifier                 shift and go to state 23
    simple_type                    shift and go to state 24

state 16

    (7) args -> args , var_decl .

    ,               reduce using rule 7 (args -> args , var_decl .)
    )               reduce using rule 7 (args -> args , var_decl .)


state 17

    (14) declaration_local -> function .

    ;               reduce using rule 14 (declaration_local -> function .)


state 18

    (4) function -> FUN ID ( arglist ) localslist . BEGIN statementBlock END

    BEGIN           shift and go to state 27


state 19

    (12) locals -> declaration_local . ;

    ;               shift and go to state 28


state 20

    (13) declaration_local -> var_decl .

    ;               reduce using rule 13 (declaration_local -> var_decl .)


state 21

    (10) localslist -> empty .

    BEGIN           reduce using rule 10 (localslist -> empty .)


state 22

    (9) localslist -> locals .
    (11) locals -> locals . declaration_local ;
    (13) declaration_local -> . var_decl
    (14) declaration_local -> . function
    (15) var_decl -> . ID : type_specifier
    (4) function -> . FUN ID ( arglist ) localslist BEGIN statementBlock END

    BEGIN           reduce using rule 9 (localslist -> locals .)
    ID              shift and go to state 11
    FUN             shift and go to state 4

    function                       shift and go to state 17
    declaration_local              shift and go to state 29
    var_decl                       shift and go to state 20

state 23

    (15) var_decl -> ID : type_specifier .

    ,               reduce using rule 15 (var_decl -> ID : type_specifier .)
    )               reduce using rule 15 (var_decl -> ID : type_specifier .)
    ;               reduce using rule 15 (var_decl -> ID : type_specifier .)


state 24

    (16) type_specifier -> simple_type .
    (17) type_specifier -> simple_type . [ INTEGER ]

    ,               reduce using rule 16 (type_specifier -> simple_type .)
    )               reduce using rule 16 (type_specifier -> simple_type .)
    ;               reduce using rule 16 (type_specifier -> simple_type .)
    [               shift and go to state 30


state 25

    (18) simple_type -> INT .

    [               reduce using rule 18 (simple_type -> INT .)
    ,               reduce using rule 18 (simple_type -> INT .)
    )               reduce using rule 18 (simple_type -> INT .)
    ;               reduce using rule 18 (simple_type -> INT .)


state 26

    (19) simple_type -> FLOAT .

    [               reduce using rule 19 (simple_type -> FLOAT .)
    ,               reduce using rule 19 (simple_type -> FLOAT .)
    )               reduce using rule 19 (simple_type -> FLOAT .)
    ;               reduce using rule 19 (simple_type -> FLOAT .)


state 27

    (4) function -> FUN ID ( arglist ) localslist BEGIN . statementBlock END
    (20) statementBlock -> . statementBlock ; statement
    (21) statementBlock -> . statement
    (22) statement -> . WHILE relation DO statement
    (23) statement -> . ifthen
    (24) statement -> . ifthenelse
    (25) statement -> . location ASIGN expression
    (26) statement -> . inOutExpr
    (27) statement -> . RETURN expression
    (28) statement -> . RETURN
    (29) statement -> . functionCall
    (30) statement -> . SKIP
    (31) statement -> . BREAK
    (32) statement -> . BEGIN statementBlock END
    (33) ifthen -> . IF relation THEN statement
    (34) ifthenelse -> . IF relation THEN statement ELSE statement
    (43) location -> . ID
    (44) location -> . ID [ expression ]
    (40) inOutExpr -> . PRINT ( STRING )
    (41) inOutExpr -> . WRITE ( expression )
    (42) inOutExpr -> . READ ( location )
    (35) functionCall -> . ID ( paramslistop )

    WHILE           shift and go to state 36
    RETURN          shift and go to state 32
    SKIP            shift and go to state 42
    BREAK           shift and go to state 47
    BEGIN           shift and go to state 38
    IF              shift and go to state 46
    ID              shift and go to state 45
    PRINT           shift and go to state 35
    WRITE           shift and go to state 43
    READ            shift and go to state 33

    statementBlock                 shift and go to state 31
    ifthenelse                     shift and go to state 41
    inOutExpr                      shift and go to state 34
    location                       shift and go to state 39
    statement                      shift and go to state 40
    functionCall                   shift and go to state 44
    ifthen                         shift and go to state 37

state 28

    (12) locals -> declaration_local ; .

    ID              reduce using rule 12 (locals -> declaration_local ; .)
    FUN             reduce using rule 12 (locals -> declaration_local ; .)
    BEGIN           reduce using rule 12 (locals -> declaration_local ; .)


state 29

    (11) locals -> locals declaration_local . ;

    ;               shift and go to state 48


state 30

    (17) type_specifier -> simple_type [ . INTEGER ]

    INTEGER         shift and go to state 49


state 31

    (4) function -> FUN ID ( arglist ) localslist BEGIN statementBlock . END
    (20) statementBlock -> statementBlock . ; statement

    END             shift and go to state 50
    ;               shift and go to state 51


state 32

    (27) statement -> RETURN . expression
    (28) statement -> RETURN .
    (57) expression -> . expression + expression
    (58) expression -> . expression - expression
    (59) expression -> . expression * expression
    (60) expression -> . expression / expression
    (61) expression -> . - expression
    (62) expression -> . + expression
    (63) expression -> . ( expression )
    (64) expression -> . ID
    (65) expression -> . number
    (66) expression -> . ID [ expression ]
    (67) expression -> . casting
    (68) expression -> . functionCall
    (71) number -> . INTEGER
    (72) number -> . FLOATNUM
    (69) casting -> . INT ( expression )
    (70) casting -> . FLOAT ( expression )
    (35) functionCall -> . ID ( paramslistop )

    END             reduce using rule 28 (statement -> RETURN .)
    ;               reduce using rule 28 (statement -> RETURN .)
    ELSE            reduce using rule 28 (statement -> RETURN .)
    -               shift and go to state 55
    +               shift and go to state 54
    (               shift and go to state 53
    ID              shift and go to state 63
    INTEGER         shift and go to state 60
    FLOATNUM        shift and go to state 59
    INT             shift and go to state 57
    FLOAT           shift and go to state 52

    functionCall                   shift and go to state 58
    casting                        shift and go to state 61
    expression                     shift and go to state 62
    number                         shift and go to state 56

state 33

    (42) inOutExpr -> READ . ( location )

    (               shift and go to state 64


state 34

    (26) statement -> inOutExpr .

    END             reduce using rule 26 (statement -> inOutExpr .)
    ;               reduce using rule 26 (statement -> inOutExpr .)
    ELSE            reduce using rule 26 (statement -> inOutExpr .)


state 35

    (40) inOutExpr -> PRINT . ( STRING )

    (               shift and go to state 65


state 36

    (22) statement -> WHILE . relation DO statement
    (45) relation -> . relation OR relation
    (46) relation -> . relation AND relation
    (47) relation -> . NOT relation
    (48) relation -> . ( relation )
    (49) relation -> . expression LT expression
    (50) relation -> . expression LE expression
    (51) relation -> . expression GT expression
    (52) relation -> . expression GE expression
    (53) relation -> . expression NE expression
    (54) relation -> . expression EQUAL expression
    (55) relation -> . TRUE
    (56) relation -> . FALSE
    (57) expression -> . expression + expression
    (58) expression -> . expression - expression
    (59) expression -> . expression * expression
    (60) expression -> . expression / expression
    (61) expression -> . - expression
    (62) expression -> . + expression
    (63) expression -> . ( expression )
    (64) expression -> . ID
    (65) expression -> . number
    (66) expression -> . ID [ expression ]
    (67) expression -> . casting
    (68) expression -> . functionCall
    (71) number -> . INTEGER
    (72) number -> . FLOATNUM
    (69) casting -> . INT ( expression )
    (70) casting -> . FLOAT ( expression )
    (35) functionCall -> . ID ( paramslistop )

    NOT             shift and go to state 70
    (               shift and go to state 68
    TRUE            shift and go to state 67
    FALSE           shift and go to state 69
    -               shift and go to state 55
    +               shift and go to state 54
    ID              shift and go to state 63
    INTEGER         shift and go to state 60
    FLOATNUM        shift and go to state 59
    INT             shift and go to state 57
    FLOAT           shift and go to state 52

    casting                        shift and go to state 61
    number                         shift and go to state 56
    functionCall                   shift and go to state 58
    relation                       shift and go to state 66
    expression                     shift and go to state 71

state 37

    (23) statement -> ifthen .

    END             reduce using rule 23 (statement -> ifthen .)
    ;               reduce using rule 23 (statement -> ifthen .)
    ELSE            reduce using rule 23 (statement -> ifthen .)


state 38

    (32) statement -> BEGIN . statementBlock END
    (20) statementBlock -> . statementBlock ; statement
    (21) statementBlock -> . statement
    (22) statement -> . WHILE relation DO statement
    (23) statement -> . ifthen
    (24) statement -> . ifthenelse
    (25) statement -> . location ASIGN expression
    (26) statement -> . inOutExpr
    (27) statement -> . RETURN expression
    (28) statement -> . RETURN
    (29) statement -> . functionCall
    (30) statement -> . SKIP
    (31) statement -> . BREAK
    (32) statement -> . BEGIN statementBlock END
    (33) ifthen -> . IF relation THEN statement
    (34) ifthenelse -> . IF relation THEN statement ELSE statement
    (43) location -> . ID
    (44) location -> . ID [ expression ]
    (40) inOutExpr -> . PRINT ( STRING )
    (41) inOutExpr -> . WRITE ( expression )
    (42) inOutExpr -> . READ ( location )
    (35) functionCall -> . ID ( paramslistop )

    WHILE           shift and go to state 36
    RETURN          shift and go to state 32
    SKIP            shift and go to state 42
    BREAK           shift and go to state 47
    BEGIN           shift and go to state 38
    IF              shift and go to state 46
    ID              shift and go to state 45
    PRINT           shift and go to state 35
    WRITE           shift and go to state 43
    READ            shift and go to state 33

    statementBlock                 shift and go to state 72
    ifthenelse                     shift and go to state 41
    inOutExpr                      shift and go to state 34
    location                       shift and go to state 39
    statement                      shift and go to state 40
    functionCall                   shift and go to state 44
    ifthen                         shift and go to state 37

state 39

    (25) statement -> location . ASIGN expression

    ASIGN           shift and go to state 73


state 40

    (21) statementBlock -> statement .

    END             reduce using rule 21 (statementBlock -> statement .)
    ;               reduce using rule 21 (statementBlock -> statement .)


state 41

    (24) statement -> ifthenelse .

    END             reduce using rule 24 (statement -> ifthenelse .)
    ;               reduce using rule 24 (statement -> ifthenelse .)
    ELSE            reduce using rule 24 (statement -> ifthenelse .)


state 42

    (30) statement -> SKIP .

    END             reduce using rule 30 (statement -> SKIP .)
    ;               reduce using rule 30 (statement -> SKIP .)
    ELSE            reduce using rule 30 (statement -> SKIP .)


state 43

    (41) inOutExpr -> WRITE . ( expression )

    (               shift and go to state 74


state 44

    (29) statement -> functionCall .

    END             reduce using rule 29 (statement -> functionCall .)
    ;               reduce using rule 29 (statement -> functionCall .)
    ELSE            reduce using rule 29 (statement -> functionCall .)


state 45

    (43) location -> ID .
    (44) location -> ID . [ expression ]
    (35) functionCall -> ID . ( paramslistop )

    ASIGN           reduce using rule 43 (location -> ID .)
    [               shift and go to state 76
    (               shift and go to state 75


state 46

    (33) ifthen -> IF . relation THEN statement
    (34) ifthenelse -> IF . relation THEN statement ELSE statement
    (45) relation -> . relation OR relation
    (46) relation -> . relation AND relation
    (47) relation -> . NOT relation
    (48) relation -> . ( relation )
    (49) relation -> . expression LT expression
    (50) relation -> . expression LE expression
    (51) relation -> . expression GT expression
    (52) relation -> . expression GE expression
    (53) relation -> . expression NE expression
    (54) relation -> . expression EQUAL expression
    (55) relation -> . TRUE
    (56) relation -> . FALSE
    (57) expression -> . expression + expression
    (58) expression -> . expression - expression
    (59) expression -> . expression * expression
    (60) expression -> . expression / expression
    (61) expression -> . - expression
    (62) expression -> . + expression
    (63) expression -> . ( expression )
    (64) expression -> . ID
    (65) expression -> . number
    (66) expression -> . ID [ expression ]
    (67) expression -> . casting
    (68) expression -> . functionCall
    (71) number -> . INTEGER
    (72) number -> . FLOATNUM
    (69) casting -> . INT ( expression )
    (70) casting -> . FLOAT ( expression )
    (35) functionCall -> . ID ( paramslistop )

    NOT             shift and go to state 70
    (               shift and go to state 68
    TRUE            shift and go to state 67
    FALSE           shift and go to state 69
    -               shift and go to state 55
    +               shift and go to state 54
    ID              shift and go to state 63
    INTEGER         shift and go to state 60
    FLOATNUM        shift and go to state 59
    INT             shift and go to state 57
    FLOAT           shift and go to state 52

    casting                        shift and go to state 61
    number                         shift and go to state 56
    functionCall                   shift and go to state 58
    relation                       shift and go to state 77
    expression                     shift and go to state 71

state 47

    (31) statement -> BREAK .

    END             reduce using rule 31 (statement -> BREAK .)
    ;               reduce using rule 31 (statement -> BREAK .)
    ELSE            reduce using rule 31 (statement -> BREAK .)


state 48

    (11) locals -> locals declaration_local ; .

    ID              reduce using rule 11 (locals -> locals declaration_local ; .)
    FUN             reduce using rule 11 (locals -> locals declaration_local ; .)
    BEGIN           reduce using rule 11 (locals -> locals declaration_local ; .)


state 49

    (17) type_specifier -> simple_type [ INTEGER . ]

    ]               shift and go to state 78


state 50

    (4) function -> FUN ID ( arglist ) localslist BEGIN statementBlock END .

    ;               reduce using rule 4 (function -> FUN ID ( arglist ) localslist BEGIN statementBlock END .)
    FUN             reduce using rule 4 (function -> FUN ID ( arglist ) localslist BEGIN statementBlock END .)
    $end            reduce using rule 4 (function -> FUN ID ( arglist ) localslist BEGIN statementBlock END .)


state 51

    (20) statementBlock -> statementBlock ; . statement
    (22) statement -> . WHILE relation DO statement
    (23) statement -> . ifthen
    (24) statement -> . ifthenelse
    (25) statement -> . location ASIGN expression
    (26) statement -> . inOutExpr
    (27) statement -> . RETURN expression
    (28) statement -> . RETURN
    (29) statement -> . functionCall
    (30) statement -> . SKIP
    (31) statement -> . BREAK
    (32) statement -> . BEGIN statementBlock END
    (33) ifthen -> . IF relation THEN statement
    (34) ifthenelse -> . IF relation THEN statement ELSE statement
    (43) location -> . ID
    (44) location -> . ID [ expression ]
    (40) inOutExpr -> . PRINT ( STRING )
    (41) inOutExpr -> . WRITE ( expression )
    (42) inOutExpr -> . READ ( location )
    (35) functionCall -> . ID ( paramslistop )

    WHILE           shift and go to state 36
    RETURN          shift and go to state 32
    SKIP            shift and go to state 42
    BREAK           shift and go to state 47
    BEGIN           shift and go to state 38
    IF              shift and go to state 46
    ID              shift and go to state 45
    PRINT           shift and go to state 35
    WRITE           shift and go to state 43
    READ            shift and go to state 33

    ifthenelse                     shift and go to state 41
    inOutExpr                      shift and go to state 34
    location                       shift and go to state 39
    statement                      shift and go to state 79
    functionCall                   shift and go to state 44
    ifthen                         shift and go to state 37

state 52

    (70) casting -> FLOAT . ( expression )

    (               shift and go to state 80


state 53

    (63) expression -> ( . expression )
    (57) expression -> . expression + expression
    (58) expression -> . expression - expression
    (59) expression -> . expression * expression
    (60) expression -> . expression / expression
    (61) expression -> . - expression
    (62) expression -> . + expression
    (63) expression -> . ( expression )
    (64) expression -> . ID
    (65) expression -> . number
    (66) expression -> . ID [ expression ]
    (67) expression -> . casting
    (68) expression -> . functionCall
    (71) number -> . INTEGER
    (72) number -> . FLOATNUM
    (69) casting -> . INT ( expression )
    (70) casting -> . FLOAT ( expression )
    (35) functionCall -> . ID ( paramslistop )

    -               shift and go to state 55
    +               shift and go to state 54
    (               shift and go to state 53
    ID              shift and go to state 63
    INTEGER         shift and go to state 60
    FLOATNUM        shift and go to state 59
    INT             shift and go to state 57
    FLOAT           shift and go to state 52

    functionCall                   shift and go to state 58
    casting                        shift and go to state 61
    expression                     shift and go to state 81
    number                         shift and go to state 56

state 54

    (62) expression -> + . expression
    (57) expression -> . expression + expression
    (58) expression -> . expression - expression
    (59) expression -> . expression * expression
    (60) expression -> . expression / expression
    (61) expression -> . - expression
    (62) expression -> . + expression
    (63) expression -> . ( expression )
    (64) expression -> . ID
    (65) expression -> . number
    (66) expression -> . ID [ expression ]
    (67) expression -> . casting
    (68) expression -> . functionCall
    (71) number -> . INTEGER
    (72) number -> . FLOATNUM
    (69) casting -> . INT ( expression )
    (70) casting -> . FLOAT ( expression )
    (35) functionCall -> . ID ( paramslistop )

    -               shift and go to state 55
    +               shift and go to state 54
    (               shift and go to state 53
    ID              shift and go to state 63
    INTEGER         shift and go to state 60
    FLOATNUM        shift and go to state 59
    INT             shift and go to state 57
    FLOAT           shift and go to state 52

    functionCall                   shift and go to state 58
    casting                        shift and go to state 61
    expression                     shift and go to state 82
    number                         shift and go to state 56

state 55

    (61) expression -> - . expression
    (57) expression -> . expression + expression
    (58) expression -> . expression - expression
    (59) expression -> . expression * expression
    (60) expression -> . expression / expression
    (61) expression -> . - expression
    (62) expression -> . + expression
    (63) expression -> . ( expression )
    (64) expression -> . ID
    (65) expression -> . number
    (66) expression -> . ID [ expression ]
    (67) expression -> . casting
    (68) expression -> . functionCall
    (71) number -> . INTEGER
    (72) number -> . FLOATNUM
    (69) casting -> . INT ( expression )
    (70) casting -> . FLOAT ( expression )
    (35) functionCall -> . ID ( paramslistop )

    -               shift and go to state 55
    +               shift and go to state 54
    (               shift and go to state 53
    ID              shift and go to state 63
    INTEGER         shift and go to state 60
    FLOATNUM        shift and go to state 59
    INT             shift and go to state 57
    FLOAT           shift and go to state 52

    functionCall                   shift and go to state 58
    casting                        shift and go to state 61
    expression                     shift and go to state 83
    number                         shift and go to state 56

state 56

    (65) expression -> number .

    +               reduce using rule 65 (expression -> number .)
    -               reduce using rule 65 (expression -> number .)
    *               reduce using rule 65 (expression -> number .)
    /               reduce using rule 65 (expression -> number .)
    DO              reduce using rule 65 (expression -> number .)
    OR              reduce using rule 65 (expression -> number .)
    AND             reduce using rule 65 (expression -> number .)
    THEN            reduce using rule 65 (expression -> number .)
    )               reduce using rule 65 (expression -> number .)
    LT              reduce using rule 65 (expression -> number .)
    LE              reduce using rule 65 (expression -> number .)
    GT              reduce using rule 65 (expression -> number .)
    GE              reduce using rule 65 (expression -> number .)
    NE              reduce using rule 65 (expression -> number .)
    EQUAL           reduce using rule 65 (expression -> number .)
    END             reduce using rule 65 (expression -> number .)
    ;               reduce using rule 65 (expression -> number .)
    ELSE            reduce using rule 65 (expression -> number .)
    ,               reduce using rule 65 (expression -> number .)
    ]               reduce using rule 65 (expression -> number .)


state 57

    (69) casting -> INT . ( expression )

    (               shift and go to state 84


state 58

    (68) expression -> functionCall .

    +               reduce using rule 68 (expression -> functionCall .)
    -               reduce using rule 68 (expression -> functionCall .)
    *               reduce using rule 68 (expression -> functionCall .)
    /               reduce using rule 68 (expression -> functionCall .)
    DO              reduce using rule 68 (expression -> functionCall .)
    OR              reduce using rule 68 (expression -> functionCall .)
    AND             reduce using rule 68 (expression -> functionCall .)
    THEN            reduce using rule 68 (expression -> functionCall .)
    )               reduce using rule 68 (expression -> functionCall .)
    LT              reduce using rule 68 (expression -> functionCall .)
    LE              reduce using rule 68 (expression -> functionCall .)
    GT              reduce using rule 68 (expression -> functionCall .)
    GE              reduce using rule 68 (expression -> functionCall .)
    NE              reduce using rule 68 (expression -> functionCall .)
    EQUAL           reduce using rule 68 (expression -> functionCall .)
    END             reduce using rule 68 (expression -> functionCall .)
    ;               reduce using rule 68 (expression -> functionCall .)
    ELSE            reduce using rule 68 (expression -> functionCall .)
    ,               reduce using rule 68 (expression -> functionCall .)
    ]               reduce using rule 68 (expression -> functionCall .)


state 59

    (72) number -> FLOATNUM .

    +               reduce using rule 72 (number -> FLOATNUM .)
    -               reduce using rule 72 (number -> FLOATNUM .)
    *               reduce using rule 72 (number -> FLOATNUM .)
    /               reduce using rule 72 (number -> FLOATNUM .)
    END             reduce using rule 72 (number -> FLOATNUM .)
    ;               reduce using rule 72 (number -> FLOATNUM .)
    ELSE            reduce using rule 72 (number -> FLOATNUM .)
    LT              reduce using rule 72 (number -> FLOATNUM .)
    LE              reduce using rule 72 (number -> FLOATNUM .)
    GT              reduce using rule 72 (number -> FLOATNUM .)
    GE              reduce using rule 72 (number -> FLOATNUM .)
    NE              reduce using rule 72 (number -> FLOATNUM .)
    EQUAL           reduce using rule 72 (number -> FLOATNUM .)
    )               reduce using rule 72 (number -> FLOATNUM .)
    ,               reduce using rule 72 (number -> FLOATNUM .)
    ]               reduce using rule 72 (number -> FLOATNUM .)
    DO              reduce using rule 72 (number -> FLOATNUM .)
    OR              reduce using rule 72 (number -> FLOATNUM .)
    AND             reduce using rule 72 (number -> FLOATNUM .)
    THEN            reduce using rule 72 (number -> FLOATNUM .)


state 60

    (71) number -> INTEGER .

    +               reduce using rule 71 (number -> INTEGER .)
    -               reduce using rule 71 (number -> INTEGER .)
    *               reduce using rule 71 (number -> INTEGER .)
    /               reduce using rule 71 (number -> INTEGER .)
    END             reduce using rule 71 (number -> INTEGER .)
    ;               reduce using rule 71 (number -> INTEGER .)
    ELSE            reduce using rule 71 (number -> INTEGER .)
    LT              reduce using rule 71 (number -> INTEGER .)
    LE              reduce using rule 71 (number -> INTEGER .)
    GT              reduce using rule 71 (number -> INTEGER .)
    GE              reduce using rule 71 (number -> INTEGER .)
    NE              reduce using rule 71 (number -> INTEGER .)
    EQUAL           reduce using rule 71 (number -> INTEGER .)
    )               reduce using rule 71 (number -> INTEGER .)
    ,               reduce using rule 71 (number -> INTEGER .)
    ]               reduce using rule 71 (number -> INTEGER .)
    DO              reduce using rule 71 (number -> INTEGER .)
    OR              reduce using rule 71 (number -> INTEGER .)
    AND             reduce using rule 71 (number -> INTEGER .)
    THEN            reduce using rule 71 (number -> INTEGER .)


state 61

    (67) expression -> casting .

    +               reduce using rule 67 (expression -> casting .)
    -               reduce using rule 67 (expression -> casting .)
    *               reduce using rule 67 (expression -> casting .)
    /               reduce using rule 67 (expression -> casting .)
    DO              reduce using rule 67 (expression -> casting .)
    OR              reduce using rule 67 (expression -> casting .)
    AND             reduce using rule 67 (expression -> casting .)
    THEN            reduce using rule 67 (expression -> casting .)
    )               reduce using rule 67 (expression -> casting .)
    LT              reduce using rule 67 (expression -> casting .)
    LE              reduce using rule 67 (expression -> casting .)
    GT              reduce using rule 67 (expression -> casting .)
    GE              reduce using rule 67 (expression -> casting .)
    NE              reduce using rule 67 (expression -> casting .)
    EQUAL           reduce using rule 67 (expression -> casting .)
    END             reduce using rule 67 (expression -> casting .)
    ;               reduce using rule 67 (expression -> casting .)
    ELSE            reduce using rule 67 (expression -> casting .)
    ,               reduce using rule 67 (expression -> casting .)
    ]               reduce using rule 67 (expression -> casting .)


state 62

    (27) statement -> RETURN expression .
    (57) expression -> expression . + expression
    (58) expression -> expression . - expression
    (59) expression -> expression . * expression
    (60) expression -> expression . / expression

    END             reduce using rule 27 (statement -> RETURN expression .)
    ;               reduce using rule 27 (statement -> RETURN expression .)
    ELSE            reduce using rule 27 (statement -> RETURN expression .)
    +               shift and go to state 85
    -               shift and go to state 87
    *               shift and go to state 86
    /               shift and go to state 88


state 63

    (64) expression -> ID .
    (66) expression -> ID . [ expression ]
    (35) functionCall -> ID . ( paramslistop )

    +               reduce using rule 64 (expression -> ID .)
    -               reduce using rule 64 (expression -> ID .)
    *               reduce using rule 64 (expression -> ID .)
    /               reduce using rule 64 (expression -> ID .)
    DO              reduce using rule 64 (expression -> ID .)
    OR              reduce using rule 64 (expression -> ID .)
    AND             reduce using rule 64 (expression -> ID .)
    THEN            reduce using rule 64 (expression -> ID .)
    )               reduce using rule 64 (expression -> ID .)
    LT              reduce using rule 64 (expression -> ID .)
    LE              reduce using rule 64 (expression -> ID .)
    GT              reduce using rule 64 (expression -> ID .)
    GE              reduce using rule 64 (expression -> ID .)
    NE              reduce using rule 64 (expression -> ID .)
    EQUAL           reduce using rule 64 (expression -> ID .)
    END             reduce using rule 64 (expression -> ID .)
    ;               reduce using rule 64 (expression -> ID .)
    ELSE            reduce using rule 64 (expression -> ID .)
    ,               reduce using rule 64 (expression -> ID .)
    ]               reduce using rule 64 (expression -> ID .)
    [               shift and go to state 89
    (               shift and go to state 75


state 64

    (42) inOutExpr -> READ ( . location )
    (43) location -> . ID
    (44) location -> . ID [ expression ]

    ID              shift and go to state 91

    location                       shift and go to state 90

state 65

    (40) inOutExpr -> PRINT ( . STRING )

    STRING          shift and go to state 92


state 66

    (22) statement -> WHILE relation . DO statement
    (45) relation -> relation . OR relation
    (46) relation -> relation . AND relation

    DO              shift and go to state 94
    OR              shift and go to state 95
    AND             shift and go to state 93


state 67

    (55) relation -> TRUE .

    )               reduce using rule 55 (relation -> TRUE .)
    OR              reduce using rule 55 (relation -> TRUE .)
    AND             reduce using rule 55 (relation -> TRUE .)
    DO              reduce using rule 55 (relation -> TRUE .)
    THEN            reduce using rule 55 (relation -> TRUE .)


state 68

    (48) relation -> ( . relation )
    (63) expression -> ( . expression )
    (45) relation -> . relation OR relation
    (46) relation -> . relation AND relation
    (47) relation -> . NOT relation
    (48) relation -> . ( relation )
    (49) relation -> . expression LT expression
    (50) relation -> . expression LE expression
    (51) relation -> . expression GT expression
    (52) relation -> . expression GE expression
    (53) relation -> . expression NE expression
    (54) relation -> . expression EQUAL expression
    (55) relation -> . TRUE
    (56) relation -> . FALSE
    (57) expression -> . expression + expression
    (58) expression -> . expression - expression
    (59) expression -> . expression * expression
    (60) expression -> . expression / expression
    (61) expression -> . - expression
    (62) expression -> . + expression
    (63) expression -> . ( expression )
    (64) expression -> . ID
    (65) expression -> . number
    (66) expression -> . ID [ expression ]
    (67) expression -> . casting
    (68) expression -> . functionCall
    (71) number -> . INTEGER
    (72) number -> . FLOATNUM
    (69) casting -> . INT ( expression )
    (70) casting -> . FLOAT ( expression )
    (35) functionCall -> . ID ( paramslistop )

    NOT             shift and go to state 70
    (               shift and go to state 68
    TRUE            shift and go to state 67
    FALSE           shift and go to state 69
    -               shift and go to state 55
    +               shift and go to state 54
    ID              shift and go to state 63
    INTEGER         shift and go to state 60
    FLOATNUM        shift and go to state 59
    INT             shift and go to state 57
    FLOAT           shift and go to state 52

    casting                        shift and go to state 61
    number                         shift and go to state 56
    relation                       shift and go to state 96
    functionCall                   shift and go to state 58
    expression                     shift and go to state 97

state 69

    (56) relation -> FALSE .

    )               reduce using rule 56 (relation -> FALSE .)
    OR              reduce using rule 56 (relation -> FALSE .)
    AND             reduce using rule 56 (relation -> FALSE .)
    DO              reduce using rule 56 (relation -> FALSE .)
    THEN            reduce using rule 56 (relation -> FALSE .)


state 70

    (47) relation -> NOT . relation
    (45) relation -> . relation OR relation
    (46) relation -> . relation AND relation
    (47) relation -> . NOT relation
    (48) relation -> . ( relation )
    (49) relation -> . expression LT expression
    (50) relation -> . expression LE expression
    (51) relation -> . expression GT expression
    (52) relation -> . expression GE expression
    (53) relation -> . expression NE expression
    (54) relation -> . expression EQUAL expression
    (55) relation -> . TRUE
    (56) relation -> . FALSE
    (57) expression -> . expression + expression
    (58) expression -> . expression - expression
    (59) expression -> . expression * expression
    (60) expression -> . expression / expression
    (61) expression -> . - expression
    (62) expression -> . + expression
    (63) expression -> . ( expression )
    (64) expression -> . ID
    (65) expression -> . number
    (66) expression -> . ID [ expression ]
    (67) expression -> . casting
    (68) expression -> . functionCall
    (71) number -> . INTEGER
    (72) number -> . FLOATNUM
    (69) casting -> . INT ( expression )
    (70) casting -> . FLOAT ( expression )
    (35) functionCall -> . ID ( paramslistop )

    NOT             shift and go to state 70
    (               shift and go to state 68
    TRUE            shift and go to state 67
    FALSE           shift and go to state 69
    -               shift and go to state 55
    +               shift and go to state 54
    ID              shift and go to state 63
    INTEGER         shift and go to state 60
    FLOATNUM        shift and go to state 59
    INT             shift and go to state 57
    FLOAT           shift and go to state 52

    casting                        shift and go to state 61
    number                         shift and go to state 56
    relation                       shift and go to state 98
    functionCall                   shift and go to state 58
    expression                     shift and go to state 71

state 71

    (49) relation -> expression . LT expression
    (50) relation -> expression . LE expression
    (51) relation -> expression . GT expression
    (52) relation -> expression . GE expression
    (53) relation -> expression . NE expression
    (54) relation -> expression . EQUAL expression
    (57) expression -> expression . + expression
    (58) expression -> expression . - expression
    (59) expression -> expression . * expression
    (60) expression -> expression . / expression

    LT              shift and go to state 103
    LE              shift and go to state 99
    GT              shift and go to state 104
    GE              shift and go to state 101
    NE              shift and go to state 102
    EQUAL           shift and go to state 100
    +               shift and go to state 85
    -               shift and go to state 87
    *               shift and go to state 86
    /               shift and go to state 88


state 72

    (32) statement -> BEGIN statementBlock . END
    (20) statementBlock -> statementBlock . ; statement

    END             shift and go to state 105
    ;               shift and go to state 51


state 73

    (25) statement -> location ASIGN . expression
    (57) expression -> . expression + expression
    (58) expression -> . expression - expression
    (59) expression -> . expression * expression
    (60) expression -> . expression / expression
    (61) expression -> . - expression
    (62) expression -> . + expression
    (63) expression -> . ( expression )
    (64) expression -> . ID
    (65) expression -> . number
    (66) expression -> . ID [ expression ]
    (67) expression -> . casting
    (68) expression -> . functionCall
    (71) number -> . INTEGER
    (72) number -> . FLOATNUM
    (69) casting -> . INT ( expression )
    (70) casting -> . FLOAT ( expression )
    (35) functionCall -> . ID ( paramslistop )

    -               shift and go to state 55
    +               shift and go to state 54
    (               shift and go to state 53
    ID              shift and go to state 63
    INTEGER         shift and go to state 60
    FLOATNUM        shift and go to state 59
    INT             shift and go to state 57
    FLOAT           shift and go to state 52

    casting                        shift and go to state 61
    number                         shift and go to state 56
    functionCall                   shift and go to state 58
    expression                     shift and go to state 106

state 74

    (41) inOutExpr -> WRITE ( . expression )
    (57) expression -> . expression + expression
    (58) expression -> . expression - expression
    (59) expression -> . expression * expression
    (60) expression -> . expression / expression
    (61) expression -> . - expression
    (62) expression -> . + expression
    (63) expression -> . ( expression )
    (64) expression -> . ID
    (65) expression -> . number
    (66) expression -> . ID [ expression ]
    (67) expression -> . casting
    (68) expression -> . functionCall
    (71) number -> . INTEGER
    (72) number -> . FLOATNUM
    (69) casting -> . INT ( expression )
    (70) casting -> . FLOAT ( expression )
    (35) functionCall -> . ID ( paramslistop )

    -               shift and go to state 55
    +               shift and go to state 54
    (               shift and go to state 53
    ID              shift and go to state 63
    INTEGER         shift and go to state 60
    FLOATNUM        shift and go to state 59
    INT             shift and go to state 57
    FLOAT           shift and go to state 52

    functionCall                   shift and go to state 58
    casting                        shift and go to state 61
    expression                     shift and go to state 107
    number                         shift and go to state 56

state 75

    (35) functionCall -> ID ( . paramslistop )
    (36) paramslistop -> . paramList
    (37) paramslistop -> . empty
    (38) paramList -> . paramList , expression
    (39) paramList -> . expression
    (73) empty -> .
    (57) expression -> . expression + expression
    (58) expression -> . expression - expression
    (59) expression -> . expression * expression
    (60) expression -> . expression / expression
    (61) expression -> . - expression
    (62) expression -> . + expression
    (63) expression -> . ( expression )
    (64) expression -> . ID
    (65) expression -> . number
    (66) expression -> . ID [ expression ]
    (67) expression -> . casting
    (68) expression -> . functionCall
    (71) number -> . INTEGER
    (72) number -> . FLOATNUM
    (69) casting -> . INT ( expression )
    (70) casting -> . FLOAT ( expression )
    (35) functionCall -> . ID ( paramslistop )

    )               reduce using rule 73 (empty -> .)
    -               shift and go to state 55
    +               shift and go to state 54
    (               shift and go to state 53
    ID              shift and go to state 63
    INTEGER         shift and go to state 60
    FLOATNUM        shift and go to state 59
    INT             shift and go to state 57
    FLOAT           shift and go to state 52

    casting                        shift and go to state 61
    paramslistop                   shift and go to state 108
    number                         shift and go to state 56
    functionCall                   shift and go to state 58
    paramList                      shift and go to state 109
    expression                     shift and go to state 110
    empty                          shift and go to state 111

state 76

    (44) location -> ID [ . expression ]
    (57) expression -> . expression + expression
    (58) expression -> . expression - expression
    (59) expression -> . expression * expression
    (60) expression -> . expression / expression
    (61) expression -> . - expression
    (62) expression -> . + expression
    (63) expression -> . ( expression )
    (64) expression -> . ID
    (65) expression -> . number
    (66) expression -> . ID [ expression ]
    (67) expression -> . casting
    (68) expression -> . functionCall
    (71) number -> . INTEGER
    (72) number -> . FLOATNUM
    (69) casting -> . INT ( expression )
    (70) casting -> . FLOAT ( expression )
    (35) functionCall -> . ID ( paramslistop )

    -               shift and go to state 55
    +               shift and go to state 54
    (               shift and go to state 53
    ID              shift and go to state 63
    INTEGER         shift and go to state 60
    FLOATNUM        shift and go to state 59
    INT             shift and go to state 57
    FLOAT           shift and go to state 52

    functionCall                   shift and go to state 58
    casting                        shift and go to state 61
    expression                     shift and go to state 112
    number                         shift and go to state 56

state 77

    (33) ifthen -> IF relation . THEN statement
    (34) ifthenelse -> IF relation . THEN statement ELSE statement
    (45) relation -> relation . OR relation
    (46) relation -> relation . AND relation

    THEN            shift and go to state 113
    OR              shift and go to state 95
    AND             shift and go to state 93


state 78

    (17) type_specifier -> simple_type [ INTEGER ] .

    ,               reduce using rule 17 (type_specifier -> simple_type [ INTEGER ] .)
    )               reduce using rule 17 (type_specifier -> simple_type [ INTEGER ] .)
    ;               reduce using rule 17 (type_specifier -> simple_type [ INTEGER ] .)


state 79

    (20) statementBlock -> statementBlock ; statement .

    END             reduce using rule 20 (statementBlock -> statementBlock ; statement .)
    ;               reduce using rule 20 (statementBlock -> statementBlock ; statement .)


state 80

    (70) casting -> FLOAT ( . expression )
    (57) expression -> . expression + expression
    (58) expression -> . expression - expression
    (59) expression -> . expression * expression
    (60) expression -> . expression / expression
    (61) expression -> . - expression
    (62) expression -> . + expression
    (63) expression -> . ( expression )
    (64) expression -> . ID
    (65) expression -> . number
    (66) expression -> . ID [ expression ]
    (67) expression -> . casting
    (68) expression -> . functionCall
    (71) number -> . INTEGER
    (72) number -> . FLOATNUM
    (69) casting -> . INT ( expression )
    (70) casting -> . FLOAT ( expression )
    (35) functionCall -> . ID ( paramslistop )

    -               shift and go to state 55
    +               shift and go to state 54
    (               shift and go to state 53
    ID              shift and go to state 63
    INTEGER         shift and go to state 60
    FLOATNUM        shift and go to state 59
    INT             shift and go to state 57
    FLOAT           shift and go to state 52

    functionCall                   shift and go to state 58
    casting                        shift and go to state 61
    expression                     shift and go to state 114
    number                         shift and go to state 56

state 81

    (63) expression -> ( expression . )
    (57) expression -> expression . + expression
    (58) expression -> expression . - expression
    (59) expression -> expression . * expression
    (60) expression -> expression . / expression

    )               shift and go to state 115
    +               shift and go to state 85
    -               shift and go to state 87
    *               shift and go to state 86
    /               shift and go to state 88


state 82

    (62) expression -> + expression .
    (57) expression -> expression . + expression
    (58) expression -> expression . - expression
    (59) expression -> expression . * expression
    (60) expression -> expression . / expression

    +               reduce using rule 62 (expression -> + expression .)
    -               reduce using rule 62 (expression -> + expression .)
    *               reduce using rule 62 (expression -> + expression .)
    /               reduce using rule 62 (expression -> + expression .)
    DO              reduce using rule 62 (expression -> + expression .)
    OR              reduce using rule 62 (expression -> + expression .)
    AND             reduce using rule 62 (expression -> + expression .)
    THEN            reduce using rule 62 (expression -> + expression .)
    )               reduce using rule 62 (expression -> + expression .)
    LT              reduce using rule 62 (expression -> + expression .)
    LE              reduce using rule 62 (expression -> + expression .)
    GT              reduce using rule 62 (expression -> + expression .)
    GE              reduce using rule 62 (expression -> + expression .)
    NE              reduce using rule 62 (expression -> + expression .)
    EQUAL           reduce using rule 62 (expression -> + expression .)
    END             reduce using rule 62 (expression -> + expression .)
    ;               reduce using rule 62 (expression -> + expression .)
    ELSE            reduce using rule 62 (expression -> + expression .)
    ,               reduce using rule 62 (expression -> + expression .)
    ]               reduce using rule 62 (expression -> + expression .)

  ! +               [ shift and go to state 85 ]
  ! -               [ shift and go to state 87 ]
  ! *               [ shift and go to state 86 ]
  ! /               [ shift and go to state 88 ]


state 83

    (61) expression -> - expression .
    (57) expression -> expression . + expression
    (58) expression -> expression . - expression
    (59) expression -> expression . * expression
    (60) expression -> expression . / expression

    +               reduce using rule 61 (expression -> - expression .)
    -               reduce using rule 61 (expression -> - expression .)
    *               reduce using rule 61 (expression -> - expression .)
    /               reduce using rule 61 (expression -> - expression .)
    DO              reduce using rule 61 (expression -> - expression .)
    OR              reduce using rule 61 (expression -> - expression .)
    AND             reduce using rule 61 (expression -> - expression .)
    THEN            reduce using rule 61 (expression -> - expression .)
    )               reduce using rule 61 (expression -> - expression .)
    LT              reduce using rule 61 (expression -> - expression .)
    LE              reduce using rule 61 (expression -> - expression .)
    GT              reduce using rule 61 (expression -> - expression .)
    GE              reduce using rule 61 (expression -> - expression .)
    NE              reduce using rule 61 (expression -> - expression .)
    EQUAL           reduce using rule 61 (expression -> - expression .)
    END             reduce using rule 61 (expression -> - expression .)
    ;               reduce using rule 61 (expression -> - expression .)
    ELSE            reduce using rule 61 (expression -> - expression .)
    ,               reduce using rule 61 (expression -> - expression .)
    ]               reduce using rule 61 (expression -> - expression .)

  ! +               [ shift and go to state 85 ]
  ! -               [ shift and go to state 87 ]
  ! *               [ shift and go to state 86 ]
  ! /               [ shift and go to state 88 ]


state 84

    (69) casting -> INT ( . expression )
    (57) expression -> . expression + expression
    (58) expression -> . expression - expression
    (59) expression -> . expression * expression
    (60) expression -> . expression / expression
    (61) expression -> . - expression
    (62) expression -> . + expression
    (63) expression -> . ( expression )
    (64) expression -> . ID
    (65) expression -> . number
    (66) expression -> . ID [ expression ]
    (67) expression -> . casting
    (68) expression -> . functionCall
    (71) number -> . INTEGER
    (72) number -> . FLOATNUM
    (69) casting -> . INT ( expression )
    (70) casting -> . FLOAT ( expression )
    (35) functionCall -> . ID ( paramslistop )

    -               shift and go to state 55
    +               shift and go to state 54
    (               shift and go to state 53
    ID              shift and go to state 63
    INTEGER         shift and go to state 60
    FLOATNUM        shift and go to state 59
    INT             shift and go to state 57
    FLOAT           shift and go to state 52

    functionCall                   shift and go to state 58
    casting                        shift and go to state 61
    expression                     shift and go to state 116
    number                         shift and go to state 56

state 85

    (57) expression -> expression + . expression
    (57) expression -> . expression + expression
    (58) expression -> . expression - expression
    (59) expression -> . expression * expression
    (60) expression -> . expression / expression
    (61) expression -> . - expression
    (62) expression -> . + expression
    (63) expression -> . ( expression )
    (64) expression -> . ID
    (65) expression -> . number
    (66) expression -> . ID [ expression ]
    (67) expression -> . casting
    (68) expression -> . functionCall
    (71) number -> . INTEGER
    (72) number -> . FLOATNUM
    (69) casting -> . INT ( expression )
    (70) casting -> . FLOAT ( expression )
    (35) functionCall -> . ID ( paramslistop )

    -               shift and go to state 55
    +               shift and go to state 54
    (               shift and go to state 53
    ID              shift and go to state 63
    INTEGER         shift and go to state 60
    FLOATNUM        shift and go to state 59
    INT             shift and go to state 57
    FLOAT           shift and go to state 52

    functionCall                   shift and go to state 58
    casting                        shift and go to state 61
    expression                     shift and go to state 117
    number                         shift and go to state 56

state 86

    (59) expression -> expression * . expression
    (57) expression -> . expression + expression
    (58) expression -> . expression - expression
    (59) expression -> . expression * expression
    (60) expression -> . expression / expression
    (61) expression -> . - expression
    (62) expression -> . + expression
    (63) expression -> . ( expression )
    (64) expression -> . ID
    (65) expression -> . number
    (66) expression -> . ID [ expression ]
    (67) expression -> . casting
    (68) expression -> . functionCall
    (71) number -> . INTEGER
    (72) number -> . FLOATNUM
    (69) casting -> . INT ( expression )
    (70) casting -> . FLOAT ( expression )
    (35) functionCall -> . ID ( paramslistop )

    -               shift and go to state 55
    +               shift and go to state 54
    (               shift and go to state 53
    ID              shift and go to state 63
    INTEGER         shift and go to state 60
    FLOATNUM        shift and go to state 59
    INT             shift and go to state 57
    FLOAT           shift and go to state 52

    functionCall                   shift and go to state 58
    casting                        shift and go to state 61
    expression                     shift and go to state 118
    number                         shift and go to state 56

state 87

    (58) expression -> expression - . expression
    (57) expression -> . expression + expression
    (58) expression -> . expression - expression
    (59) expression -> . expression * expression
    (60) expression -> . expression / expression
    (61) expression -> . - expression
    (62) expression -> . + expression
    (63) expression -> . ( expression )
    (64) expression -> . ID
    (65) expression -> . number
    (66) expression -> . ID [ expression ]
    (67) expression -> . casting
    (68) expression -> . functionCall
    (71) number -> . INTEGER
    (72) number -> . FLOATNUM
    (69) casting -> . INT ( expression )
    (70) casting -> . FLOAT ( expression )
    (35) functionCall -> . ID ( paramslistop )

    -               shift and go to state 55
    +               shift and go to state 54
    (               shift and go to state 53
    ID              shift and go to state 63
    INTEGER         shift and go to state 60
    FLOATNUM        shift and go to state 59
    INT             shift and go to state 57
    FLOAT           shift and go to state 52

    functionCall                   shift and go to state 58
    casting                        shift and go to state 61
    expression                     shift and go to state 119
    number                         shift and go to state 56

state 88

    (60) expression -> expression / . expression
    (57) expression -> . expression + expression
    (58) expression -> . expression - expression
    (59) expression -> . expression * expression
    (60) expression -> . expression / expression
    (61) expression -> . - expression
    (62) expression -> . + expression
    (63) expression -> . ( expression )
    (64) expression -> . ID
    (65) expression -> . number
    (66) expression -> . ID [ expression ]
    (67) expression -> . casting
    (68) expression -> . functionCall
    (71) number -> . INTEGER
    (72) number -> . FLOATNUM
    (69) casting -> . INT ( expression )
    (70) casting -> . FLOAT ( expression )
    (35) functionCall -> . ID ( paramslistop )

    -               shift and go to state 55
    +               shift and go to state 54
    (               shift and go to state 53
    ID              shift and go to state 63
    INTEGER         shift and go to state 60
    FLOATNUM        shift and go to state 59
    INT             shift and go to state 57
    FLOAT           shift and go to state 52

    functionCall                   shift and go to state 58
    casting                        shift and go to state 61
    expression                     shift and go to state 120
    number                         shift and go to state 56

state 89

    (66) expression -> ID [ . expression ]
    (57) expression -> . expression + expression
    (58) expression -> . expression - expression
    (59) expression -> . expression * expression
    (60) expression -> . expression / expression
    (61) expression -> . - expression
    (62) expression -> . + expression
    (63) expression -> . ( expression )
    (64) expression -> . ID
    (65) expression -> . number
    (66) expression -> . ID [ expression ]
    (67) expression -> . casting
    (68) expression -> . functionCall
    (71) number -> . INTEGER
    (72) number -> . FLOATNUM
    (69) casting -> . INT ( expression )
    (70) casting -> . FLOAT ( expression )
    (35) functionCall -> . ID ( paramslistop )

    -               shift and go to state 55
    +               shift and go to state 54
    (               shift and go to state 53
    ID              shift and go to state 63
    INTEGER         shift and go to state 60
    FLOATNUM        shift and go to state 59
    INT             shift and go to state 57
    FLOAT           shift and go to state 52

    functionCall                   shift and go to state 58
    casting                        shift and go to state 61
    expression                     shift and go to state 121
    number                         shift and go to state 56

state 90

    (42) inOutExpr -> READ ( location . )

    )               shift and go to state 122


state 91

    (43) location -> ID .
    (44) location -> ID . [ expression ]

    )               reduce using rule 43 (location -> ID .)
    [               shift and go to state 76


state 92

    (40) inOutExpr -> PRINT ( STRING . )

    )               shift and go to state 123


state 93

    (46) relation -> relation AND . relation
    (45) relation -> . relation OR relation
    (46) relation -> . relation AND relation
    (47) relation -> . NOT relation
    (48) relation -> . ( relation )
    (49) relation -> . expression LT expression
    (50) relation -> . expression LE expression
    (51) relation -> . expression GT expression
    (52) relation -> . expression GE expression
    (53) relation -> . expression NE expression
    (54) relation -> . expression EQUAL expression
    (55) relation -> . TRUE
    (56) relation -> . FALSE
    (57) expression -> . expression + expression
    (58) expression -> . expression - expression
    (59) expression -> . expression * expression
    (60) expression -> . expression / expression
    (61) expression -> . - expression
    (62) expression -> . + expression
    (63) expression -> . ( expression )
    (64) expression -> . ID
    (65) expression -> . number
    (66) expression -> . ID [ expression ]
    (67) expression -> . casting
    (68) expression -> . functionCall
    (71) number -> . INTEGER
    (72) number -> . FLOATNUM
    (69) casting -> . INT ( expression )
    (70) casting -> . FLOAT ( expression )
    (35) functionCall -> . ID ( paramslistop )

    NOT             shift and go to state 70
    (               shift and go to state 68
    TRUE            shift and go to state 67
    FALSE           shift and go to state 69
    -               shift and go to state 55
    +               shift and go to state 54
    ID              shift and go to state 63
    INTEGER         shift and go to state 60
    FLOATNUM        shift and go to state 59
    INT             shift and go to state 57
    FLOAT           shift and go to state 52

    casting                        shift and go to state 61
    number                         shift and go to state 56
    relation                       shift and go to state 124
    functionCall                   shift and go to state 58
    expression                     shift and go to state 71

state 94

    (22) statement -> WHILE relation DO . statement
    (22) statement -> . WHILE relation DO statement
    (23) statement -> . ifthen
    (24) statement -> . ifthenelse
    (25) statement -> . location ASIGN expression
    (26) statement -> . inOutExpr
    (27) statement -> . RETURN expression
    (28) statement -> . RETURN
    (29) statement -> . functionCall
    (30) statement -> . SKIP
    (31) statement -> . BREAK
    (32) statement -> . BEGIN statementBlock END
    (33) ifthen -> . IF relation THEN statement
    (34) ifthenelse -> . IF relation THEN statement ELSE statement
    (43) location -> . ID
    (44) location -> . ID [ expression ]
    (40) inOutExpr -> . PRINT ( STRING )
    (41) inOutExpr -> . WRITE ( expression )
    (42) inOutExpr -> . READ ( location )
    (35) functionCall -> . ID ( paramslistop )

    WHILE           shift and go to state 36
    RETURN          shift and go to state 32
    SKIP            shift and go to state 42
    BREAK           shift and go to state 47
    BEGIN           shift and go to state 38
    IF              shift and go to state 46
    ID              shift and go to state 45
    PRINT           shift and go to state 35
    WRITE           shift and go to state 43
    READ            shift and go to state 33

    ifthenelse                     shift and go to state 41
    inOutExpr                      shift and go to state 34
    location                       shift and go to state 39
    statement                      shift and go to state 125
    functionCall                   shift and go to state 44
    ifthen                         shift and go to state 37

state 95

    (45) relation -> relation OR . relation
    (45) relation -> . relation OR relation
    (46) relation -> . relation AND relation
    (47) relation -> . NOT relation
    (48) relation -> . ( relation )
    (49) relation -> . expression LT expression
    (50) relation -> . expression LE expression
    (51) relation -> . expression GT expression
    (52) relation -> . expression GE expression
    (53) relation -> . expression NE expression
    (54) relation -> . expression EQUAL expression
    (55) relation -> . TRUE
    (56) relation -> . FALSE
    (57) expression -> . expression + expression
    (58) expression -> . expression - expression
    (59) expression -> . expression * expression
    (60) expression -> . expression / expression
    (61) expression -> . - expression
    (62) expression -> . + expression
    (63) expression -> . ( expression )
    (64) expression -> . ID
    (65) expression -> . number
    (66) expression -> . ID [ expression ]
    (67) expression -> . casting
    (68) expression -> . functionCall
    (71) number -> . INTEGER
    (72) number -> . FLOATNUM
    (69) casting -> . INT ( expression )
    (70) casting -> . FLOAT ( expression )
    (35) functionCall -> . ID ( paramslistop )

    NOT             shift and go to state 70
    (               shift and go to state 68
    TRUE            shift and go to state 67
    FALSE           shift and go to state 69
    -               shift and go to state 55
    +               shift and go to state 54
    ID              shift and go to state 63
    INTEGER         shift and go to state 60
    FLOATNUM        shift and go to state 59
    INT             shift and go to state 57
    FLOAT           shift and go to state 52

    casting                        shift and go to state 61
    number                         shift and go to state 56
    relation                       shift and go to state 126
    functionCall                   shift and go to state 58
    expression                     shift and go to state 71

state 96

    (48) relation -> ( relation . )
    (45) relation -> relation . OR relation
    (46) relation -> relation . AND relation

    )               shift and go to state 127
    OR              shift and go to state 95
    AND             shift and go to state 93


state 97

    (63) expression -> ( expression . )
    (49) relation -> expression . LT expression
    (50) relation -> expression . LE expression
    (51) relation -> expression . GT expression
    (52) relation -> expression . GE expression
    (53) relation -> expression . NE expression
    (54) relation -> expression . EQUAL expression
    (57) expression -> expression . + expression
    (58) expression -> expression . - expression
    (59) expression -> expression . * expression
    (60) expression -> expression . / expression

    )               shift and go to state 115
    LT              shift and go to state 103
    LE              shift and go to state 99
    GT              shift and go to state 104
    GE              shift and go to state 101
    NE              shift and go to state 102
    EQUAL           shift and go to state 100
    +               shift and go to state 85
    -               shift and go to state 87
    *               shift and go to state 86
    /               shift and go to state 88


state 98

    (47) relation -> NOT relation .
    (45) relation -> relation . OR relation
    (46) relation -> relation . AND relation

    )               reduce using rule 47 (relation -> NOT relation .)
    OR              reduce using rule 47 (relation -> NOT relation .)
    AND             reduce using rule 47 (relation -> NOT relation .)
    DO              reduce using rule 47 (relation -> NOT relation .)
    THEN            reduce using rule 47 (relation -> NOT relation .)

  ! OR              [ shift and go to state 95 ]
  ! AND             [ shift and go to state 93 ]


state 99

    (50) relation -> expression LE . expression
    (57) expression -> . expression + expression
    (58) expression -> . expression - expression
    (59) expression -> . expression * expression
    (60) expression -> . expression / expression
    (61) expression -> . - expression
    (62) expression -> . + expression
    (63) expression -> . ( expression )
    (64) expression -> . ID
    (65) expression -> . number
    (66) expression -> . ID [ expression ]
    (67) expression -> . casting
    (68) expression -> . functionCall
    (71) number -> . INTEGER
    (72) number -> . FLOATNUM
    (69) casting -> . INT ( expression )
    (70) casting -> . FLOAT ( expression )
    (35) functionCall -> . ID ( paramslistop )

    -               shift and go to state 55
    +               shift and go to state 54
    (               shift and go to state 53
    ID              shift and go to state 63
    INTEGER         shift and go to state 60
    FLOATNUM        shift and go to state 59
    INT             shift and go to state 57
    FLOAT           shift and go to state 52

    functionCall                   shift and go to state 58
    casting                        shift and go to state 61
    expression                     shift and go to state 128
    number                         shift and go to state 56

state 100

    (54) relation -> expression EQUAL . expression
    (57) expression -> . expression + expression
    (58) expression -> . expression - expression
    (59) expression -> . expression * expression
    (60) expression -> . expression / expression
    (61) expression -> . - expression
    (62) expression -> . + expression
    (63) expression -> . ( expression )
    (64) expression -> . ID
    (65) expression -> . number
    (66) expression -> . ID [ expression ]
    (67) expression -> . casting
    (68) expression -> . functionCall
    (71) number -> . INTEGER
    (72) number -> . FLOATNUM
    (69) casting -> . INT ( expression )
    (70) casting -> . FLOAT ( expression )
    (35) functionCall -> . ID ( paramslistop )

    -               shift and go to state 55
    +               shift and go to state 54
    (               shift and go to state 53
    ID              shift and go to state 63
    INTEGER         shift and go to state 60
    FLOATNUM        shift and go to state 59
    INT             shift and go to state 57
    FLOAT           shift and go to state 52

    functionCall                   shift and go to state 58
    casting                        shift and go to state 61
    expression                     shift and go to state 129
    number                         shift and go to state 56

state 101

    (52) relation -> expression GE . expression
    (57) expression -> . expression + expression
    (58) expression -> . expression - expression
    (59) expression -> . expression * expression
    (60) expression -> . expression / expression
    (61) expression -> . - expression
    (62) expression -> . + expression
    (63) expression -> . ( expression )
    (64) expression -> . ID
    (65) expression -> . number
    (66) expression -> . ID [ expression ]
    (67) expression -> . casting
    (68) expression -> . functionCall
    (71) number -> . INTEGER
    (72) number -> . FLOATNUM
    (69) casting -> . INT ( expression )
    (70) casting -> . FLOAT ( expression )
    (35) functionCall -> . ID ( paramslistop )

    -               shift and go to state 55
    +               shift and go to state 54
    (               shift and go to state 53
    ID              shift and go to state 63
    INTEGER         shift and go to state 60
    FLOATNUM        shift and go to state 59
    INT             shift and go to state 57
    FLOAT           shift and go to state 52

    functionCall                   shift and go to state 58
    casting                        shift and go to state 61
    expression                     shift and go to state 130
    number                         shift and go to state 56

state 102

    (53) relation -> expression NE . expression
    (57) expression -> . expression + expression
    (58) expression -> . expression - expression
    (59) expression -> . expression * expression
    (60) expression -> . expression / expression
    (61) expression -> . - expression
    (62) expression -> . + expression
    (63) expression -> . ( expression )
    (64) expression -> . ID
    (65) expression -> . number
    (66) expression -> . ID [ expression ]
    (67) expression -> . casting
    (68) expression -> . functionCall
    (71) number -> . INTEGER
    (72) number -> . FLOATNUM
    (69) casting -> . INT ( expression )
    (70) casting -> . FLOAT ( expression )
    (35) functionCall -> . ID ( paramslistop )

    -               shift and go to state 55
    +               shift and go to state 54
    (               shift and go to state 53
    ID              shift and go to state 63
    INTEGER         shift and go to state 60
    FLOATNUM        shift and go to state 59
    INT             shift and go to state 57
    FLOAT           shift and go to state 52

    functionCall                   shift and go to state 58
    casting                        shift and go to state 61
    expression                     shift and go to state 131
    number                         shift and go to state 56

state 103

    (49) relation -> expression LT . expression
    (57) expression -> . expression + expression
    (58) expression -> . expression - expression
    (59) expression -> . expression * expression
    (60) expression -> . expression / expression
    (61) expression -> . - expression
    (62) expression -> . + expression
    (63) expression -> . ( expression )
    (64) expression -> . ID
    (65) expression -> . number
    (66) expression -> . ID [ expression ]
    (67) expression -> . casting
    (68) expression -> . functionCall
    (71) number -> . INTEGER
    (72) number -> . FLOATNUM
    (69) casting -> . INT ( expression )
    (70) casting -> . FLOAT ( expression )
    (35) functionCall -> . ID ( paramslistop )

    -               shift and go to state 55
    +               shift and go to state 54
    (               shift and go to state 53
    ID              shift and go to state 63
    INTEGER         shift and go to state 60
    FLOATNUM        shift and go to state 59
    INT             shift and go to state 57
    FLOAT           shift and go to state 52

    functionCall                   shift and go to state 58
    casting                        shift and go to state 61
    expression                     shift and go to state 132
    number                         shift and go to state 56

state 104

    (51) relation -> expression GT . expression
    (57) expression -> . expression + expression
    (58) expression -> . expression - expression
    (59) expression -> . expression * expression
    (60) expression -> . expression / expression
    (61) expression -> . - expression
    (62) expression -> . + expression
    (63) expression -> . ( expression )
    (64) expression -> . ID
    (65) expression -> . number
    (66) expression -> . ID [ expression ]
    (67) expression -> . casting
    (68) expression -> . functionCall
    (71) number -> . INTEGER
    (72) number -> . FLOATNUM
    (69) casting -> . INT ( expression )
    (70) casting -> . FLOAT ( expression )
    (35) functionCall -> . ID ( paramslistop )

    -               shift and go to state 55
    +               shift and go to state 54
    (               shift and go to state 53
    ID              shift and go to state 63
    INTEGER         shift and go to state 60
    FLOATNUM        shift and go to state 59
    INT             shift and go to state 57
    FLOAT           shift and go to state 52

    functionCall                   shift and go to state 58
    casting                        shift and go to state 61
    expression                     shift and go to state 133
    number                         shift and go to state 56

state 105

    (32) statement -> BEGIN statementBlock END .

    END             reduce using rule 32 (statement -> BEGIN statementBlock END .)
    ;               reduce using rule 32 (statement -> BEGIN statementBlock END .)
    ELSE            reduce using rule 32 (statement -> BEGIN statementBlock END .)


state 106

    (25) statement -> location ASIGN expression .
    (57) expression -> expression . + expression
    (58) expression -> expression . - expression
    (59) expression -> expression . * expression
    (60) expression -> expression . / expression

    END             reduce using rule 25 (statement -> location ASIGN expression .)
    ;               reduce using rule 25 (statement -> location ASIGN expression .)
    ELSE            reduce using rule 25 (statement -> location ASIGN expression .)
    +               shift and go to state 85
    -               shift and go to state 87
    *               shift and go to state 86
    /               shift and go to state 88


state 107

    (41) inOutExpr -> WRITE ( expression . )
    (57) expression -> expression . + expression
    (58) expression -> expression . - expression
    (59) expression -> expression . * expression
    (60) expression -> expression . / expression

    )               shift and go to state 134
    +               shift and go to state 85
    -               shift and go to state 87
    *               shift and go to state 86
    /               shift and go to state 88


state 108

    (35) functionCall -> ID ( paramslistop . )

    )               shift and go to state 135


state 109

    (36) paramslistop -> paramList .
    (38) paramList -> paramList . , expression

    )               reduce using rule 36 (paramslistop -> paramList .)
    ,               shift and go to state 136


state 110

    (39) paramList -> expression .
    (57) expression -> expression . + expression
    (58) expression -> expression . - expression
    (59) expression -> expression . * expression
    (60) expression -> expression . / expression

    ,               reduce using rule 39 (paramList -> expression .)
    )               reduce using rule 39 (paramList -> expression .)
    +               shift and go to state 85
    -               shift and go to state 87
    *               shift and go to state 86
    /               shift and go to state 88


state 111

    (37) paramslistop -> empty .

    )               reduce using rule 37 (paramslistop -> empty .)


state 112

    (44) location -> ID [ expression . ]
    (57) expression -> expression . + expression
    (58) expression -> expression . - expression
    (59) expression -> expression . * expression
    (60) expression -> expression . / expression

    ]               shift and go to state 137
    +               shift and go to state 85
    -               shift and go to state 87
    *               shift and go to state 86
    /               shift and go to state 88


state 113

    (33) ifthen -> IF relation THEN . statement
    (34) ifthenelse -> IF relation THEN . statement ELSE statement
    (22) statement -> . WHILE relation DO statement
    (23) statement -> . ifthen
    (24) statement -> . ifthenelse
    (25) statement -> . location ASIGN expression
    (26) statement -> . inOutExpr
    (27) statement -> . RETURN expression
    (28) statement -> . RETURN
    (29) statement -> . functionCall
    (30) statement -> . SKIP
    (31) statement -> . BREAK
    (32) statement -> . BEGIN statementBlock END
    (33) ifthen -> . IF relation THEN statement
    (34) ifthenelse -> . IF relation THEN statement ELSE statement
    (43) location -> . ID
    (44) location -> . ID [ expression ]
    (40) inOutExpr -> . PRINT ( STRING )
    (41) inOutExpr -> . WRITE ( expression )
    (42) inOutExpr -> . READ ( location )
    (35) functionCall -> . ID ( paramslistop )

    WHILE           shift and go to state 36
    RETURN          shift and go to state 32
    SKIP            shift and go to state 42
    BREAK           shift and go to state 47
    BEGIN           shift and go to state 38
    IF              shift and go to state 46
    ID              shift and go to state 45
    PRINT           shift and go to state 35
    WRITE           shift and go to state 43
    READ            shift and go to state 33

    ifthenelse                     shift and go to state 41
    inOutExpr                      shift and go to state 34
    location                       shift and go to state 39
    statement                      shift and go to state 138
    functionCall                   shift and go to state 44
    ifthen                         shift and go to state 37

state 114

    (70) casting -> FLOAT ( expression . )
    (57) expression -> expression . + expression
    (58) expression -> expression . - expression
    (59) expression -> expression . * expression
    (60) expression -> expression . / expression

    )               shift and go to state 139
    +               shift and go to state 85
    -               shift and go to state 87
    *               shift and go to state 86
    /               shift and go to state 88


state 115

    (63) expression -> ( expression ) .

    +               reduce using rule 63 (expression -> ( expression ) .)
    -               reduce using rule 63 (expression -> ( expression ) .)
    *               reduce using rule 63 (expression -> ( expression ) .)
    /               reduce using rule 63 (expression -> ( expression ) .)
    DO              reduce using rule 63 (expression -> ( expression ) .)
    OR              reduce using rule 63 (expression -> ( expression ) .)
    AND             reduce using rule 63 (expression -> ( expression ) .)
    THEN            reduce using rule 63 (expression -> ( expression ) .)
    )               reduce using rule 63 (expression -> ( expression ) .)
    LT              reduce using rule 63 (expression -> ( expression ) .)
    LE              reduce using rule 63 (expression -> ( expression ) .)
    GT              reduce using rule 63 (expression -> ( expression ) .)
    GE              reduce using rule 63 (expression -> ( expression ) .)
    NE              reduce using rule 63 (expression -> ( expression ) .)
    EQUAL           reduce using rule 63 (expression -> ( expression ) .)
    END             reduce using rule 63 (expression -> ( expression ) .)
    ;               reduce using rule 63 (expression -> ( expression ) .)
    ELSE            reduce using rule 63 (expression -> ( expression ) .)
    ,               reduce using rule 63 (expression -> ( expression ) .)
    ]               reduce using rule 63 (expression -> ( expression ) .)


state 116

    (69) casting -> INT ( expression . )
    (57) expression -> expression . + expression
    (58) expression -> expression . - expression
    (59) expression -> expression . * expression
    (60) expression -> expression . / expression

    )               shift and go to state 140
    +               shift and go to state 85
    -               shift and go to state 87
    *               shift and go to state 86
    /               shift and go to state 88


state 117

    (57) expression -> expression + expression .
    (57) expression -> expression . + expression
    (58) expression -> expression . - expression
    (59) expression -> expression . * expression
    (60) expression -> expression . / expression

    +               reduce using rule 57 (expression -> expression + expression .)
    -               reduce using rule 57 (expression -> expression + expression .)
    DO              reduce using rule 57 (expression -> expression + expression .)
    OR              reduce using rule 57 (expression -> expression + expression .)
    AND             reduce using rule 57 (expression -> expression + expression .)
    THEN            reduce using rule 57 (expression -> expression + expression .)
    )               reduce using rule 57 (expression -> expression + expression .)
    LT              reduce using rule 57 (expression -> expression + expression .)
    LE              reduce using rule 57 (expression -> expression + expression .)
    GT              reduce using rule 57 (expression -> expression + expression .)
    GE              reduce using rule 57 (expression -> expression + expression .)
    NE              reduce using rule 57 (expression -> expression + expression .)
    EQUAL           reduce using rule 57 (expression -> expression + expression .)
    END             reduce using rule 57 (expression -> expression + expression .)
    ;               reduce using rule 57 (expression -> expression + expression .)
    ELSE            reduce using rule 57 (expression -> expression + expression .)
    ,               reduce using rule 57 (expression -> expression + expression .)
    ]               reduce using rule 57 (expression -> expression + expression .)
    *               shift and go to state 86
    /               shift and go to state 88

  ! *               [ reduce using rule 57 (expression -> expression + expression .) ]
  ! /               [ reduce using rule 57 (expression -> expression + expression .) ]
  ! +               [ shift and go to state 85 ]
  ! -               [ shift and go to state 87 ]


state 118

    (59) expression -> expression * expression .
    (57) expression -> expression . + expression
    (58) expression -> expression . - expression
    (59) expression -> expression . * expression
    (60) expression -> expression . / expression

    +               reduce using rule 59 (expression -> expression * expression .)
    -               reduce using rule 59 (expression -> expression * expression .)
    *               reduce using rule 59 (expression -> expression * expression .)
    /               reduce using rule 59 (expression -> expression * expression .)
    DO              reduce using rule 59 (expression -> expression * expression .)
    OR              reduce using rule 59 (expression -> expression * expression .)
    AND             reduce using rule 59 (expression -> expression * expression .)
    THEN            reduce using rule 59 (expression -> expression * expression .)
    )               reduce using rule 59 (expression -> expression * expression .)
    LT              reduce using rule 59 (expression -> expression * expression .)
    LE              reduce using rule 59 (expression -> expression * expression .)
    GT              reduce using rule 59 (expression -> expression * expression .)
    GE              reduce using rule 59 (expression -> expression * expression .)
    NE              reduce using rule 59 (expression -> expression * expression .)
    EQUAL           reduce using rule 59 (expression -> expression * expression .)
    END             reduce using rule 59 (expression -> expression * expression .)
    ;               reduce using rule 59 (expression -> expression * expression .)
    ELSE            reduce using rule 59 (expression -> expression * expression .)
    ,               reduce using rule 59 (expression -> expression * expression .)
    ]               reduce using rule 59 (expression -> expression * expression .)

  ! +               [ shift and go to state 85 ]
  ! -               [ shift and go to state 87 ]
  ! *               [ shift and go to state 86 ]
  ! /               [ shift and go to state 88 ]


state 119

    (58) expression -> expression - expression .
    (57) expression -> expression . + expression
    (58) expression -> expression . - expression
    (59) expression -> expression . * expression
    (60) expression -> expression . / expression

    +               reduce using rule 58 (expression -> expression - expression .)
    -               reduce using rule 58 (expression -> expression - expression .)
    DO              reduce using rule 58 (expression -> expression - expression .)
    OR              reduce using rule 58 (expression -> expression - expression .)
    AND             reduce using rule 58 (expression -> expression - expression .)
    THEN            reduce using rule 58 (expression -> expression - expression .)
    )               reduce using rule 58 (expression -> expression - expression .)
    LT              reduce using rule 58 (expression -> expression - expression .)
    LE              reduce using rule 58 (expression -> expression - expression .)
    GT              reduce using rule 58 (expression -> expression - expression .)
    GE              reduce using rule 58 (expression -> expression - expression .)
    NE              reduce using rule 58 (expression -> expression - expression .)
    EQUAL           reduce using rule 58 (expression -> expression - expression .)
    END             reduce using rule 58 (expression -> expression - expression .)
    ;               reduce using rule 58 (expression -> expression - expression .)
    ELSE            reduce using rule 58 (expression -> expression - expression .)
    ,               reduce using rule 58 (expression -> expression - expression .)
    ]               reduce using rule 58 (expression -> expression - expression .)
    *               shift and go to state 86
    /               shift and go to state 88

  ! *               [ reduce using rule 58 (expression -> expression - expression .) ]
  ! /               [ reduce using rule 58 (expression -> expression - expression .) ]
  ! +               [ shift and go to state 85 ]
  ! -               [ shift and go to state 87 ]


state 120

    (60) expression -> expression / expression .
    (57) expression -> expression . + expression
    (58) expression -> expression . - expression
    (59) expression -> expression . * expression
    (60) expression -> expression . / expression

    +               reduce using rule 60 (expression -> expression / expression .)
    -               reduce using rule 60 (expression -> expression / expression .)
    *               reduce using rule 60 (expression -> expression / expression .)
    /               reduce using rule 60 (expression -> expression / expression .)
    DO              reduce using rule 60 (expression -> expression / expression .)
    OR              reduce using rule 60 (expression -> expression / expression .)
    AND             reduce using rule 60 (expression -> expression / expression .)
    THEN            reduce using rule 60 (expression -> expression / expression .)
    )               reduce using rule 60 (expression -> expression / expression .)
    LT              reduce using rule 60 (expression -> expression / expression .)
    LE              reduce using rule 60 (expression -> expression / expression .)
    GT              reduce using rule 60 (expression -> expression / expression .)
    GE              reduce using rule 60 (expression -> expression / expression .)
    NE              reduce using rule 60 (expression -> expression / expression .)
    EQUAL           reduce using rule 60 (expression -> expression / expression .)
    END             reduce using rule 60 (expression -> expression / expression .)
    ;               reduce using rule 60 (expression -> expression / expression .)
    ELSE            reduce using rule 60 (expression -> expression / expression .)
    ,               reduce using rule 60 (expression -> expression / expression .)
    ]               reduce using rule 60 (expression -> expression / expression .)

  ! +               [ shift and go to state 85 ]
  ! -               [ shift and go to state 87 ]
  ! *               [ shift and go to state 86 ]
  ! /               [ shift and go to state 88 ]


state 121

    (66) expression -> ID [ expression . ]
    (57) expression -> expression . + expression
    (58) expression -> expression . - expression
    (59) expression -> expression . * expression
    (60) expression -> expression . / expression

    ]               shift and go to state 141
    +               shift and go to state 85
    -               shift and go to state 87
    *               shift and go to state 86
    /               shift and go to state 88


state 122

    (42) inOutExpr -> READ ( location ) .

    END             reduce using rule 42 (inOutExpr -> READ ( location ) .)
    ;               reduce using rule 42 (inOutExpr -> READ ( location ) .)
    ELSE            reduce using rule 42 (inOutExpr -> READ ( location ) .)


state 123

    (40) inOutExpr -> PRINT ( STRING ) .

    END             reduce using rule 40 (inOutExpr -> PRINT ( STRING ) .)
    ;               reduce using rule 40 (inOutExpr -> PRINT ( STRING ) .)
    ELSE            reduce using rule 40 (inOutExpr -> PRINT ( STRING ) .)


state 124

    (46) relation -> relation AND relation .
    (45) relation -> relation . OR relation
    (46) relation -> relation . AND relation

    )               reduce using rule 46 (relation -> relation AND relation .)
    OR              reduce using rule 46 (relation -> relation AND relation .)
    AND             reduce using rule 46 (relation -> relation AND relation .)
    DO              reduce using rule 46 (relation -> relation AND relation .)
    THEN            reduce using rule 46 (relation -> relation AND relation .)

  ! OR              [ shift and go to state 95 ]
  ! AND             [ shift and go to state 93 ]


state 125

    (22) statement -> WHILE relation DO statement .

    END             reduce using rule 22 (statement -> WHILE relation DO statement .)
    ;               reduce using rule 22 (statement -> WHILE relation DO statement .)
    ELSE            reduce using rule 22 (statement -> WHILE relation DO statement .)


state 126

    (45) relation -> relation OR relation .
    (45) relation -> relation . OR relation
    (46) relation -> relation . AND relation

    )               reduce using rule 45 (relation -> relation OR relation .)
    OR              reduce using rule 45 (relation -> relation OR relation .)
    DO              reduce using rule 45 (relation -> relation OR relation .)
    THEN            reduce using rule 45 (relation -> relation OR relation .)
    AND             shift and go to state 93

  ! AND             [ reduce using rule 45 (relation -> relation OR relation .) ]
  ! OR              [ shift and go to state 95 ]


state 127

    (48) relation -> ( relation ) .

    )               reduce using rule 48 (relation -> ( relation ) .)
    OR              reduce using rule 48 (relation -> ( relation ) .)
    AND             reduce using rule 48 (relation -> ( relation ) .)
    DO              reduce using rule 48 (relation -> ( relation ) .)
    THEN            reduce using rule 48 (relation -> ( relation ) .)


state 128

    (50) relation -> expression LE expression .
    (57) expression -> expression . + expression
    (58) expression -> expression . - expression
    (59) expression -> expression . * expression
    (60) expression -> expression . / expression

    )               reduce using rule 50 (relation -> expression LE expression .)
    OR              reduce using rule 50 (relation -> expression LE expression .)
    AND             reduce using rule 50 (relation -> expression LE expression .)
    DO              reduce using rule 50 (relation -> expression LE expression .)
    THEN            reduce using rule 50 (relation -> expression LE expression .)
    +               shift and go to state 85
    -               shift and go to state 87
    *               shift and go to state 86
    /               shift and go to state 88


state 129

    (54) relation -> expression EQUAL expression .
    (57) expression -> expression . + expression
    (58) expression -> expression . - expression
    (59) expression -> expression . * expression
    (60) expression -> expression . / expression

    )               reduce using rule 54 (relation -> expression EQUAL expression .)
    OR              reduce using rule 54 (relation -> expression EQUAL expression .)
    AND             reduce using rule 54 (relation -> expression EQUAL expression .)
    DO              reduce using rule 54 (relation -> expression EQUAL expression .)
    THEN            reduce using rule 54 (relation -> expression EQUAL expression .)
    +               shift and go to state 85
    -               shift and go to state 87
    *               shift and go to state 86
    /               shift and go to state 88


state 130

    (52) relation -> expression GE expression .
    (57) expression -> expression . + expression
    (58) expression -> expression . - expression
    (59) expression -> expression . * expression
    (60) expression -> expression . / expression

    )               reduce using rule 52 (relation -> expression GE expression .)
    OR              reduce using rule 52 (relation -> expression GE expression .)
    AND             reduce using rule 52 (relation -> expression GE expression .)
    DO              reduce using rule 52 (relation -> expression GE expression .)
    THEN            reduce using rule 52 (relation -> expression GE expression .)
    +               shift and go to state 85
    -               shift and go to state 87
    *               shift and go to state 86
    /               shift and go to state 88


state 131

    (53) relation -> expression NE expression .
    (57) expression -> expression . + expression
    (58) expression -> expression . - expression
    (59) expression -> expression . * expression
    (60) expression -> expression . / expression

    )               reduce using rule 53 (relation -> expression NE expression .)
    OR              reduce using rule 53 (relation -> expression NE expression .)
    AND             reduce using rule 53 (relation -> expression NE expression .)
    DO              reduce using rule 53 (relation -> expression NE expression .)
    THEN            reduce using rule 53 (relation -> expression NE expression .)
    +               shift and go to state 85
    -               shift and go to state 87
    *               shift and go to state 86
    /               shift and go to state 88


state 132

    (49) relation -> expression LT expression .
    (57) expression -> expression . + expression
    (58) expression -> expression . - expression
    (59) expression -> expression . * expression
    (60) expression -> expression . / expression

    )               reduce using rule 49 (relation -> expression LT expression .)
    OR              reduce using rule 49 (relation -> expression LT expression .)
    AND             reduce using rule 49 (relation -> expression LT expression .)
    DO              reduce using rule 49 (relation -> expression LT expression .)
    THEN            reduce using rule 49 (relation -> expression LT expression .)
    +               shift and go to state 85
    -               shift and go to state 87
    *               shift and go to state 86
    /               shift and go to state 88


state 133

    (51) relation -> expression GT expression .
    (57) expression -> expression . + expression
    (58) expression -> expression . - expression
    (59) expression -> expression . * expression
    (60) expression -> expression . / expression

    )               reduce using rule 51 (relation -> expression GT expression .)
    OR              reduce using rule 51 (relation -> expression GT expression .)
    AND             reduce using rule 51 (relation -> expression GT expression .)
    DO              reduce using rule 51 (relation -> expression GT expression .)
    THEN            reduce using rule 51 (relation -> expression GT expression .)
    +               shift and go to state 85
    -               shift and go to state 87
    *               shift and go to state 86
    /               shift and go to state 88


state 134

    (41) inOutExpr -> WRITE ( expression ) .

    END             reduce using rule 41 (inOutExpr -> WRITE ( expression ) .)
    ;               reduce using rule 41 (inOutExpr -> WRITE ( expression ) .)
    ELSE            reduce using rule 41 (inOutExpr -> WRITE ( expression ) .)


state 135

    (35) functionCall -> ID ( paramslistop ) .

    +               reduce using rule 35 (functionCall -> ID ( paramslistop ) .)
    -               reduce using rule 35 (functionCall -> ID ( paramslistop ) .)
    *               reduce using rule 35 (functionCall -> ID ( paramslistop ) .)
    /               reduce using rule 35 (functionCall -> ID ( paramslistop ) .)
    END             reduce using rule 35 (functionCall -> ID ( paramslistop ) .)
    ;               reduce using rule 35 (functionCall -> ID ( paramslistop ) .)
    ELSE            reduce using rule 35 (functionCall -> ID ( paramslistop ) .)
    LT              reduce using rule 35 (functionCall -> ID ( paramslistop ) .)
    LE              reduce using rule 35 (functionCall -> ID ( paramslistop ) .)
    GT              reduce using rule 35 (functionCall -> ID ( paramslistop ) .)
    GE              reduce using rule 35 (functionCall -> ID ( paramslistop ) .)
    NE              reduce using rule 35 (functionCall -> ID ( paramslistop ) .)
    EQUAL           reduce using rule 35 (functionCall -> ID ( paramslistop ) .)
    )               reduce using rule 35 (functionCall -> ID ( paramslistop ) .)
    ,               reduce using rule 35 (functionCall -> ID ( paramslistop ) .)
    ]               reduce using rule 35 (functionCall -> ID ( paramslistop ) .)
    DO              reduce using rule 35 (functionCall -> ID ( paramslistop ) .)
    OR              reduce using rule 35 (functionCall -> ID ( paramslistop ) .)
    AND             reduce using rule 35 (functionCall -> ID ( paramslistop ) .)
    THEN            reduce using rule 35 (functionCall -> ID ( paramslistop ) .)


state 136

    (38) paramList -> paramList , . expression
    (57) expression -> . expression + expression
    (58) expression -> . expression - expression
    (59) expression -> . expression * expression
    (60) expression -> . expression / expression
    (61) expression -> . - expression
    (62) expression -> . + expression
    (63) expression -> . ( expression )
    (64) expression -> . ID
    (65) expression -> . number
    (66) expression -> . ID [ expression ]
    (67) expression -> . casting
    (68) expression -> . functionCall
    (71) number -> . INTEGER
    (72) number -> . FLOATNUM
    (69) casting -> . INT ( expression )
    (70) casting -> . FLOAT ( expression )
    (35) functionCall -> . ID ( paramslistop )

    -               shift and go to state 55
    +               shift and go to state 54
    (               shift and go to state 53
    ID              shift and go to state 63
    INTEGER         shift and go to state 60
    FLOATNUM        shift and go to state 59
    INT             shift and go to state 57
    FLOAT           shift and go to state 52

    casting                        shift and go to state 61
    number                         shift and go to state 56
    functionCall                   shift and go to state 58
    expression                     shift and go to state 142

state 137

    (44) location -> ID [ expression ] .

    ASIGN           reduce using rule 44 (location -> ID [ expression ] .)
    )               reduce using rule 44 (location -> ID [ expression ] .)


state 138

    (33) ifthen -> IF relation THEN statement .
    (34) ifthenelse -> IF relation THEN statement . ELSE statement

    END             reduce using rule 33 (ifthen -> IF relation THEN statement .)
    ;               reduce using rule 33 (ifthen -> IF relation THEN statement .)
    ELSE            shift and go to state 143

  ! ELSE            [ reduce using rule 33 (ifthen -> IF relation THEN statement .) ]


state 139

    (70) casting -> FLOAT ( expression ) .

    LT              reduce using rule 70 (casting -> FLOAT ( expression ) .)
    LE              reduce using rule 70 (casting -> FLOAT ( expression ) .)
    GT              reduce using rule 70 (casting -> FLOAT ( expression ) .)
    GE              reduce using rule 70 (casting -> FLOAT ( expression ) .)
    NE              reduce using rule 70 (casting -> FLOAT ( expression ) .)
    EQUAL           reduce using rule 70 (casting -> FLOAT ( expression ) .)
    +               reduce using rule 70 (casting -> FLOAT ( expression ) .)
    -               reduce using rule 70 (casting -> FLOAT ( expression ) .)
    *               reduce using rule 70 (casting -> FLOAT ( expression ) .)
    /               reduce using rule 70 (casting -> FLOAT ( expression ) .)
    DO              reduce using rule 70 (casting -> FLOAT ( expression ) .)
    OR              reduce using rule 70 (casting -> FLOAT ( expression ) .)
    AND             reduce using rule 70 (casting -> FLOAT ( expression ) .)
    THEN            reduce using rule 70 (casting -> FLOAT ( expression ) .)
    )               reduce using rule 70 (casting -> FLOAT ( expression ) .)
    END             reduce using rule 70 (casting -> FLOAT ( expression ) .)
    ;               reduce using rule 70 (casting -> FLOAT ( expression ) .)
    ELSE            reduce using rule 70 (casting -> FLOAT ( expression ) .)
    ,               reduce using rule 70 (casting -> FLOAT ( expression ) .)
    ]               reduce using rule 70 (casting -> FLOAT ( expression ) .)


state 140

    (69) casting -> INT ( expression ) .

    LT              reduce using rule 69 (casting -> INT ( expression ) .)
    LE              reduce using rule 69 (casting -> INT ( expression ) .)
    GT              reduce using rule 69 (casting -> INT ( expression ) .)
    GE              reduce using rule 69 (casting -> INT ( expression ) .)
    NE              reduce using rule 69 (casting -> INT ( expression ) .)
    EQUAL           reduce using rule 69 (casting -> INT ( expression ) .)
    +               reduce using rule 69 (casting -> INT ( expression ) .)
    -               reduce using rule 69 (casting -> INT ( expression ) .)
    *               reduce using rule 69 (casting -> INT ( expression ) .)
    /               reduce using rule 69 (casting -> INT ( expression ) .)
    DO              reduce using rule 69 (casting -> INT ( expression ) .)
    OR              reduce using rule 69 (casting -> INT ( expression ) .)
    AND             reduce using rule 69 (casting -> INT ( expression ) .)
    THEN            reduce using rule 69 (casting -> INT ( expression ) .)
    )               reduce using rule 69 (casting -> INT ( expression ) .)
    END             reduce using rule 69 (casting -> INT ( expression ) .)
    ;               reduce using rule 69 (casting -> INT ( expression ) .)
    ELSE            reduce using rule 69 (casting -> INT ( expression ) .)
    ,               reduce using rule 69 (casting -> INT ( expression ) .)
    ]               reduce using rule 69 (casting -> INT ( expression ) .)


state 141

    (66) expression -> ID [ expression ] .

    +               reduce using rule 66 (expression -> ID [ expression ] .)
    -               reduce using rule 66 (expression -> ID [ expression ] .)
    *               reduce using rule 66 (expression -> ID [ expression ] .)
    /               reduce using rule 66 (expression -> ID [ expression ] .)
    DO              reduce using rule 66 (expression -> ID [ expression ] .)
    OR              reduce using rule 66 (expression -> ID [ expression ] .)
    AND             reduce using rule 66 (expression -> ID [ expression ] .)
    THEN            reduce using rule 66 (expression -> ID [ expression ] .)
    )               reduce using rule 66 (expression -> ID [ expression ] .)
    LT              reduce using rule 66 (expression -> ID [ expression ] .)
    LE              reduce using rule 66 (expression -> ID [ expression ] .)
    GT              reduce using rule 66 (expression -> ID [ expression ] .)
    GE              reduce using rule 66 (expression -> ID [ expression ] .)
    NE              reduce using rule 66 (expression -> ID [ expression ] .)
    EQUAL           reduce using rule 66 (expression -> ID [ expression ] .)
    END             reduce using rule 66 (expression -> ID [ expression ] .)
    ;               reduce using rule 66 (expression -> ID [ expression ] .)
    ELSE            reduce using rule 66 (expression -> ID [ expression ] .)
    ,               reduce using rule 66 (expression -> ID [ expression ] .)
    ]               reduce using rule 66 (expression -> ID [ expression ] .)


state 142

    (38) paramList -> paramList , expression .
    (57) expression -> expression . + expression
    (58) expression -> expression . - expression
    (59) expression -> expression . * expression
    (60) expression -> expression . / expression

    ,               reduce using rule 38 (paramList -> paramList , expression .)
    )               reduce using rule 38 (paramList -> paramList , expression .)
    +               shift and go to state 85
    -               shift and go to state 87
    *               shift and go to state 86
    /               shift and go to state 88


state 143

    (34) ifthenelse -> IF relation THEN statement ELSE . statement
    (22) statement -> . WHILE relation DO statement
    (23) statement -> . ifthen
    (24) statement -> . ifthenelse
    (25) statement -> . location ASIGN expression
    (26) statement -> . inOutExpr
    (27) statement -> . RETURN expression
    (28) statement -> . RETURN
    (29) statement -> . functionCall
    (30) statement -> . SKIP
    (31) statement -> . BREAK
    (32) statement -> . BEGIN statementBlock END
    (33) ifthen -> . IF relation THEN statement
    (34) ifthenelse -> . IF relation THEN statement ELSE statement
    (43) location -> . ID
    (44) location -> . ID [ expression ]
    (40) inOutExpr -> . PRINT ( STRING )
    (41) inOutExpr -> . WRITE ( expression )
    (42) inOutExpr -> . READ ( location )
    (35) functionCall -> . ID ( paramslistop )

    WHILE           shift and go to state 36
    RETURN          shift and go to state 32
    SKIP            shift and go to state 42
    BREAK           shift and go to state 47
    BEGIN           shift and go to state 38
    IF              shift and go to state 46
    ID              shift and go to state 45
    PRINT           shift and go to state 35
    WRITE           shift and go to state 43
    READ            shift and go to state 33

    ifthenelse                     shift and go to state 41
    inOutExpr                      shift and go to state 34
    location                       shift and go to state 39
    statement                      shift and go to state 144
    functionCall                   shift and go to state 44
    ifthen                         shift and go to state 37

state 144

    (34) ifthenelse -> IF relation THEN statement ELSE statement .

    END             reduce using rule 34 (ifthenelse -> IF relation THEN statement ELSE statement .)
    ;               reduce using rule 34 (ifthenelse -> IF relation THEN statement ELSE statement .)
    ELSE            reduce using rule 34 (ifthenelse -> IF relation THEN statement ELSE statement .)

