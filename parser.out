Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    NEWLINE

Grammar

Rule 0     S' -> program
Rule 1     program -> funlist
Rule 2     program -> empty
Rule 3     funlist -> funlist function
Rule 4     funlist -> function
Rule 5     function -> FUN ID ( arglist ) localslist BEGIN statementBlock END
Rule 6     function -> FUN ( arglist ) localslist BEGIN statementBlock END
Rule 7     function -> FUN ID ( arglist ) localslist BEGIN statementBlock ; END
Rule 8     arglist -> args
Rule 9     arglist -> empty
Rule 10    args -> var_decl
Rule 11    args -> args , var_decl
Rule 12    args -> args var_decl
Rule 13    localslist -> locals
Rule 14    localslist -> empty
Rule 15    locals -> locals var_decl ;
Rule 16    locals -> locals function ;
Rule 17    locals -> var_decl ;
Rule 18    locals -> function ;
Rule 19    locals -> locals var_decl
Rule 20    locals -> var_decl
Rule 21    locals -> locals function
Rule 22    locals -> function
Rule 23    var_decl -> ID : type_specifier
Rule 24    var_decl -> ID type_specifier
Rule 25    var_decl -> ID ASIGN type_specifier
Rule 26    type_specifier -> simple_type
Rule 27    type_specifier -> simple_type [ INTEGER ]
Rule 28    simple_type -> INT
Rule 29    simple_type -> FLOAT
Rule 30    statementBlock -> statementBlock ; statement
Rule 31    statementBlock -> statement
Rule 32    statementBlock -> statementBlock statement
Rule 33    statement -> WHILE relation DO statement
Rule 34    statement -> ifthen
Rule 35    statement -> ifthenelse
Rule 36    statement -> location ASIGN expression
Rule 37    statement -> inOutExpr
Rule 38    statement -> RETURN expression
Rule 39    statement -> RETURN
Rule 40    statement -> functionCall
Rule 41    statement -> SKIP
Rule 42    statement -> BREAK
Rule 43    statement -> BEGIN statementBlock END
Rule 44    statement -> BEGIN END
Rule 45    ifthen -> IF relation THEN statement
Rule 46    ifthenelse -> IF relation THEN statement ELSE statement
Rule 47    ifthenelse -> IF relation statement ELSE statement
Rule 48    functionCall -> ID ( paramslistop )
Rule 49    paramslistop -> paramList
Rule 50    paramslistop -> empty
Rule 51    paramList -> paramList , expression
Rule 52    paramList -> expression
Rule 53    inOutExpr -> PRINT ( STRING )
Rule 54    inOutExpr -> WRITE ( expression )
Rule 55    inOutExpr -> READ ( location )
Rule 56    location -> ID
Rule 57    location -> ID [ expression ]
Rule 58    relation -> relation OR relation
Rule 59    relation -> relation AND relation
Rule 60    relation -> NOT relation
Rule 61    relation -> ( relation )
Rule 62    relation -> expression LT expression
Rule 63    relation -> expression LE expression
Rule 64    relation -> expression GT expression
Rule 65    relation -> expression GE expression
Rule 66    relation -> expression NE expression
Rule 67    relation -> expression EQUAL expression
Rule 68    relation -> TRUE
Rule 69    relation -> FALSE
Rule 70    expression -> expression + expression
Rule 71    expression -> expression - expression
Rule 72    expression -> expression * expression
Rule 73    expression -> expression / expression
Rule 74    expression -> - expression
Rule 75    expression -> + expression
Rule 76    expression -> ( expression )
Rule 77    expression -> ID
Rule 78    expression -> number
Rule 79    expression -> ID [ expression ]
Rule 80    expression -> casting
Rule 81    expression -> functionCall
Rule 82    casting -> INT ( expression )
Rule 83    casting -> FLOAT ( expression )
Rule 84    number -> INTEGER
Rule 85    number -> FLOATNUM
Rule 86    empty -> <empty>

Terminals, with rules where they appear

(                    : 5 6 7 48 53 54 55 61 76 82 83
)                    : 5 6 7 48 53 54 55 61 76 82 83
*                    : 72
+                    : 70 75
,                    : 11 51
-                    : 71 74
/                    : 73
:                    : 23
;                    : 7 15 16 17 18 30
AND                  : 59
ASIGN                : 25 36
BEGIN                : 5 6 7 43 44
BREAK                : 42
DO                   : 33
ELSE                 : 46 47
END                  : 5 6 7 43 44
EQUAL                : 67
FALSE                : 69
FLOAT                : 29 83
FLOATNUM             : 85
FUN                  : 5 6 7
GE                   : 65
GT                   : 64
ID                   : 5 7 23 24 25 48 56 57 77 79
IF                   : 45 46 47
INT                  : 28 82
INTEGER              : 27 84
LE                   : 63
LT                   : 62
NE                   : 66
NEWLINE              : 
NOT                  : 60
OR                   : 58
PRINT                : 53
READ                 : 55
RETURN               : 38 39
SKIP                 : 41
STRING               : 53
THEN                 : 45 46
TRUE                 : 68
WHILE                : 33
WRITE                : 54
[                    : 27 57 79
]                    : 27 57 79
error                : 

Nonterminals, with rules where they appear

arglist              : 5 6 7
args                 : 8 11 12
casting              : 80
empty                : 2 9 14 50
expression           : 36 38 51 52 54 57 62 62 63 63 64 64 65 65 66 66 67 67 70 70 71 71 72 72 73 73 74 75 76 79 82 83
function             : 3 4 16 18 21 22
functionCall         : 40 81
funlist              : 1 3
ifthen               : 34
ifthenelse           : 35
inOutExpr            : 37
locals               : 13 15 16 19 21
localslist           : 5 6 7
location             : 36 55
number               : 78
paramList            : 49 51
paramslistop         : 48
program              : 0
relation             : 33 45 46 47 58 58 59 59 60 61
simple_type          : 26 27
statement            : 30 31 32 33 45 46 46 47 47
statementBlock       : 5 6 7 30 32 43
type_specifier       : 23 24 25
var_decl             : 10 11 12 15 17 19 20

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . funlist
    (2) program -> . empty
    (3) funlist -> . funlist function
    (4) funlist -> . function
    (86) empty -> .
    (5) function -> . FUN ID ( arglist ) localslist BEGIN statementBlock END
    (6) function -> . FUN ( arglist ) localslist BEGIN statementBlock END
    (7) function -> . FUN ID ( arglist ) localslist BEGIN statementBlock ; END

    $end            reduce using rule 86 (empty -> .)
    FUN             shift and go to state 4

    function                       shift and go to state 1
    funlist                        shift and go to state 2
    program                        shift and go to state 3
    empty                          shift and go to state 5

state 1

    (4) funlist -> function .

    FUN             reduce using rule 4 (funlist -> function .)
    $end            reduce using rule 4 (funlist -> function .)


state 2

    (1) program -> funlist .
    (3) funlist -> funlist . function
    (5) function -> . FUN ID ( arglist ) localslist BEGIN statementBlock END
    (6) function -> . FUN ( arglist ) localslist BEGIN statementBlock END
    (7) function -> . FUN ID ( arglist ) localslist BEGIN statementBlock ; END

    $end            reduce using rule 1 (program -> funlist .)
    FUN             shift and go to state 4

    function                       shift and go to state 6

state 3

    (0) S' -> program .



state 4

    (5) function -> FUN . ID ( arglist ) localslist BEGIN statementBlock END
    (6) function -> FUN . ( arglist ) localslist BEGIN statementBlock END
    (7) function -> FUN . ID ( arglist ) localslist BEGIN statementBlock ; END

    ID              shift and go to state 8
    (               shift and go to state 7


state 5

    (2) program -> empty .

    $end            reduce using rule 2 (program -> empty .)


state 6

    (3) funlist -> funlist function .

    FUN             reduce using rule 3 (funlist -> funlist function .)
    $end            reduce using rule 3 (funlist -> funlist function .)


state 7

    (6) function -> FUN ( . arglist ) localslist BEGIN statementBlock END
    (8) arglist -> . args
    (9) arglist -> . empty
    (10) args -> . var_decl
    (11) args -> . args , var_decl
    (12) args -> . args var_decl
    (86) empty -> .
    (23) var_decl -> . ID : type_specifier
    (24) var_decl -> . ID type_specifier
    (25) var_decl -> . ID ASIGN type_specifier

    )               reduce using rule 86 (empty -> .)
    ID              shift and go to state 12

    args                           shift and go to state 9
    var_decl                       shift and go to state 10
    arglist                        shift and go to state 11
    empty                          shift and go to state 13

state 8

    (5) function -> FUN ID . ( arglist ) localslist BEGIN statementBlock END
    (7) function -> FUN ID . ( arglist ) localslist BEGIN statementBlock ; END

    (               shift and go to state 14


state 9

    (8) arglist -> args .
    (11) args -> args . , var_decl
    (12) args -> args . var_decl
    (23) var_decl -> . ID : type_specifier
    (24) var_decl -> . ID type_specifier
    (25) var_decl -> . ID ASIGN type_specifier

    )               reduce using rule 8 (arglist -> args .)
    ,               shift and go to state 15
    ID              shift and go to state 12

    var_decl                       shift and go to state 16

state 10

    (10) args -> var_decl .

    ,               reduce using rule 10 (args -> var_decl .)
    ID              reduce using rule 10 (args -> var_decl .)
    )               reduce using rule 10 (args -> var_decl .)


state 11

    (6) function -> FUN ( arglist . ) localslist BEGIN statementBlock END

    )               shift and go to state 17


state 12

    (23) var_decl -> ID . : type_specifier
    (24) var_decl -> ID . type_specifier
    (25) var_decl -> ID . ASIGN type_specifier
    (26) type_specifier -> . simple_type
    (27) type_specifier -> . simple_type [ INTEGER ]
    (28) simple_type -> . INT
    (29) simple_type -> . FLOAT

    :               shift and go to state 23
    ASIGN           shift and go to state 22
    INT             shift and go to state 20
    FLOAT           shift and go to state 21

    type_specifier                 shift and go to state 18
    simple_type                    shift and go to state 19

state 13

    (9) arglist -> empty .

    )               reduce using rule 9 (arglist -> empty .)


state 14

    (5) function -> FUN ID ( . arglist ) localslist BEGIN statementBlock END
    (7) function -> FUN ID ( . arglist ) localslist BEGIN statementBlock ; END
    (8) arglist -> . args
    (9) arglist -> . empty
    (10) args -> . var_decl
    (11) args -> . args , var_decl
    (12) args -> . args var_decl
    (86) empty -> .
    (23) var_decl -> . ID : type_specifier
    (24) var_decl -> . ID type_specifier
    (25) var_decl -> . ID ASIGN type_specifier

    )               reduce using rule 86 (empty -> .)
    ID              shift and go to state 12

    args                           shift and go to state 9
    var_decl                       shift and go to state 10
    arglist                        shift and go to state 24
    empty                          shift and go to state 13

state 15

    (11) args -> args , . var_decl
    (23) var_decl -> . ID : type_specifier
    (24) var_decl -> . ID type_specifier
    (25) var_decl -> . ID ASIGN type_specifier

    ID              shift and go to state 12

    var_decl                       shift and go to state 25

state 16

    (12) args -> args var_decl .

    ,               reduce using rule 12 (args -> args var_decl .)
    ID              reduce using rule 12 (args -> args var_decl .)
    )               reduce using rule 12 (args -> args var_decl .)


state 17

    (6) function -> FUN ( arglist ) . localslist BEGIN statementBlock END
    (13) localslist -> . locals
    (14) localslist -> . empty
    (15) locals -> . locals var_decl ;
    (16) locals -> . locals function ;
    (17) locals -> . var_decl ;
    (18) locals -> . function ;
    (19) locals -> . locals var_decl
    (20) locals -> . var_decl
    (21) locals -> . locals function
    (22) locals -> . function
    (86) empty -> .
    (23) var_decl -> . ID : type_specifier
    (24) var_decl -> . ID type_specifier
    (25) var_decl -> . ID ASIGN type_specifier
    (5) function -> . FUN ID ( arglist ) localslist BEGIN statementBlock END
    (6) function -> . FUN ( arglist ) localslist BEGIN statementBlock END
    (7) function -> . FUN ID ( arglist ) localslist BEGIN statementBlock ; END

    BEGIN           reduce using rule 86 (empty -> .)
    ID              shift and go to state 12
    FUN             shift and go to state 4

    function                       shift and go to state 26
    localslist                     shift and go to state 27
    var_decl                       shift and go to state 28
    locals                         shift and go to state 30
    empty                          shift and go to state 29

state 18

    (24) var_decl -> ID type_specifier .

    ,               reduce using rule 24 (var_decl -> ID type_specifier .)
    ID              reduce using rule 24 (var_decl -> ID type_specifier .)
    )               reduce using rule 24 (var_decl -> ID type_specifier .)
    ;               reduce using rule 24 (var_decl -> ID type_specifier .)
    FUN             reduce using rule 24 (var_decl -> ID type_specifier .)
    BEGIN           reduce using rule 24 (var_decl -> ID type_specifier .)


state 19

    (26) type_specifier -> simple_type .
    (27) type_specifier -> simple_type . [ INTEGER ]

    ,               reduce using rule 26 (type_specifier -> simple_type .)
    ID              reduce using rule 26 (type_specifier -> simple_type .)
    )               reduce using rule 26 (type_specifier -> simple_type .)
    ;               reduce using rule 26 (type_specifier -> simple_type .)
    FUN             reduce using rule 26 (type_specifier -> simple_type .)
    BEGIN           reduce using rule 26 (type_specifier -> simple_type .)
    [               shift and go to state 31


state 20

    (28) simple_type -> INT .

    [               reduce using rule 28 (simple_type -> INT .)
    ,               reduce using rule 28 (simple_type -> INT .)
    ID              reduce using rule 28 (simple_type -> INT .)
    )               reduce using rule 28 (simple_type -> INT .)
    ;               reduce using rule 28 (simple_type -> INT .)
    FUN             reduce using rule 28 (simple_type -> INT .)
    BEGIN           reduce using rule 28 (simple_type -> INT .)


state 21

    (29) simple_type -> FLOAT .

    [               reduce using rule 29 (simple_type -> FLOAT .)
    ,               reduce using rule 29 (simple_type -> FLOAT .)
    ID              reduce using rule 29 (simple_type -> FLOAT .)
    )               reduce using rule 29 (simple_type -> FLOAT .)
    ;               reduce using rule 29 (simple_type -> FLOAT .)
    FUN             reduce using rule 29 (simple_type -> FLOAT .)
    BEGIN           reduce using rule 29 (simple_type -> FLOAT .)


state 22

    (25) var_decl -> ID ASIGN . type_specifier
    (26) type_specifier -> . simple_type
    (27) type_specifier -> . simple_type [ INTEGER ]
    (28) simple_type -> . INT
    (29) simple_type -> . FLOAT

    INT             shift and go to state 20
    FLOAT           shift and go to state 21

    type_specifier                 shift and go to state 32
    simple_type                    shift and go to state 19

state 23

    (23) var_decl -> ID : . type_specifier
    (26) type_specifier -> . simple_type
    (27) type_specifier -> . simple_type [ INTEGER ]
    (28) simple_type -> . INT
    (29) simple_type -> . FLOAT

    INT             shift and go to state 20
    FLOAT           shift and go to state 21

    type_specifier                 shift and go to state 33
    simple_type                    shift and go to state 19

state 24

    (5) function -> FUN ID ( arglist . ) localslist BEGIN statementBlock END
    (7) function -> FUN ID ( arglist . ) localslist BEGIN statementBlock ; END

    )               shift and go to state 34


state 25

    (11) args -> args , var_decl .

    ,               reduce using rule 11 (args -> args , var_decl .)
    ID              reduce using rule 11 (args -> args , var_decl .)
    )               reduce using rule 11 (args -> args , var_decl .)


state 26

    (18) locals -> function . ;
    (22) locals -> function .

    ;               shift and go to state 35
    ID              reduce using rule 22 (locals -> function .)
    FUN             reduce using rule 22 (locals -> function .)
    BEGIN           reduce using rule 22 (locals -> function .)


state 27

    (6) function -> FUN ( arglist ) localslist . BEGIN statementBlock END

    BEGIN           shift and go to state 36


state 28

    (17) locals -> var_decl . ;
    (20) locals -> var_decl .

    ;               shift and go to state 37
    ID              reduce using rule 20 (locals -> var_decl .)
    FUN             reduce using rule 20 (locals -> var_decl .)
    BEGIN           reduce using rule 20 (locals -> var_decl .)


state 29

    (14) localslist -> empty .

    BEGIN           reduce using rule 14 (localslist -> empty .)


state 30

    (13) localslist -> locals .
    (15) locals -> locals . var_decl ;
    (16) locals -> locals . function ;
    (19) locals -> locals . var_decl
    (21) locals -> locals . function
    (23) var_decl -> . ID : type_specifier
    (24) var_decl -> . ID type_specifier
    (25) var_decl -> . ID ASIGN type_specifier
    (5) function -> . FUN ID ( arglist ) localslist BEGIN statementBlock END
    (6) function -> . FUN ( arglist ) localslist BEGIN statementBlock END
    (7) function -> . FUN ID ( arglist ) localslist BEGIN statementBlock ; END

    BEGIN           reduce using rule 13 (localslist -> locals .)
    ID              shift and go to state 12
    FUN             shift and go to state 4

    function                       shift and go to state 38
    var_decl                       shift and go to state 39

state 31

    (27) type_specifier -> simple_type [ . INTEGER ]

    INTEGER         shift and go to state 40


state 32

    (25) var_decl -> ID ASIGN type_specifier .

    ,               reduce using rule 25 (var_decl -> ID ASIGN type_specifier .)
    ID              reduce using rule 25 (var_decl -> ID ASIGN type_specifier .)
    )               reduce using rule 25 (var_decl -> ID ASIGN type_specifier .)
    ;               reduce using rule 25 (var_decl -> ID ASIGN type_specifier .)
    FUN             reduce using rule 25 (var_decl -> ID ASIGN type_specifier .)
    BEGIN           reduce using rule 25 (var_decl -> ID ASIGN type_specifier .)


state 33

    (23) var_decl -> ID : type_specifier .

    ,               reduce using rule 23 (var_decl -> ID : type_specifier .)
    ID              reduce using rule 23 (var_decl -> ID : type_specifier .)
    )               reduce using rule 23 (var_decl -> ID : type_specifier .)
    ;               reduce using rule 23 (var_decl -> ID : type_specifier .)
    FUN             reduce using rule 23 (var_decl -> ID : type_specifier .)
    BEGIN           reduce using rule 23 (var_decl -> ID : type_specifier .)


state 34

    (5) function -> FUN ID ( arglist ) . localslist BEGIN statementBlock END
    (7) function -> FUN ID ( arglist ) . localslist BEGIN statementBlock ; END
    (13) localslist -> . locals
    (14) localslist -> . empty
    (15) locals -> . locals var_decl ;
    (16) locals -> . locals function ;
    (17) locals -> . var_decl ;
    (18) locals -> . function ;
    (19) locals -> . locals var_decl
    (20) locals -> . var_decl
    (21) locals -> . locals function
    (22) locals -> . function
    (86) empty -> .
    (23) var_decl -> . ID : type_specifier
    (24) var_decl -> . ID type_specifier
    (25) var_decl -> . ID ASIGN type_specifier
    (5) function -> . FUN ID ( arglist ) localslist BEGIN statementBlock END
    (6) function -> . FUN ( arglist ) localslist BEGIN statementBlock END
    (7) function -> . FUN ID ( arglist ) localslist BEGIN statementBlock ; END

    BEGIN           reduce using rule 86 (empty -> .)
    ID              shift and go to state 12
    FUN             shift and go to state 4

    function                       shift and go to state 26
    localslist                     shift and go to state 41
    var_decl                       shift and go to state 28
    locals                         shift and go to state 30
    empty                          shift and go to state 29

state 35

    (18) locals -> function ; .

    ID              reduce using rule 18 (locals -> function ; .)
    FUN             reduce using rule 18 (locals -> function ; .)
    BEGIN           reduce using rule 18 (locals -> function ; .)


state 36

    (6) function -> FUN ( arglist ) localslist BEGIN . statementBlock END
    (30) statementBlock -> . statementBlock ; statement
    (31) statementBlock -> . statement
    (32) statementBlock -> . statementBlock statement
    (33) statement -> . WHILE relation DO statement
    (34) statement -> . ifthen
    (35) statement -> . ifthenelse
    (36) statement -> . location ASIGN expression
    (37) statement -> . inOutExpr
    (38) statement -> . RETURN expression
    (39) statement -> . RETURN
    (40) statement -> . functionCall
    (41) statement -> . SKIP
    (42) statement -> . BREAK
    (43) statement -> . BEGIN statementBlock END
    (44) statement -> . BEGIN END
    (45) ifthen -> . IF relation THEN statement
    (46) ifthenelse -> . IF relation THEN statement ELSE statement
    (47) ifthenelse -> . IF relation statement ELSE statement
    (56) location -> . ID
    (57) location -> . ID [ expression ]
    (53) inOutExpr -> . PRINT ( STRING )
    (54) inOutExpr -> . WRITE ( expression )
    (55) inOutExpr -> . READ ( location )
    (48) functionCall -> . ID ( paramslistop )

    WHILE           shift and go to state 47
    RETURN          shift and go to state 43
    SKIP            shift and go to state 53
    BREAK           shift and go to state 58
    BEGIN           shift and go to state 49
    IF              shift and go to state 57
    ID              shift and go to state 56
    PRINT           shift and go to state 46
    WRITE           shift and go to state 54
    READ            shift and go to state 44

    statementBlock                 shift and go to state 42
    ifthenelse                     shift and go to state 52
    inOutExpr                      shift and go to state 45
    location                       shift and go to state 50
    statement                      shift and go to state 51
    functionCall                   shift and go to state 55
    ifthen                         shift and go to state 48

state 37

    (17) locals -> var_decl ; .

    ID              reduce using rule 17 (locals -> var_decl ; .)
    FUN             reduce using rule 17 (locals -> var_decl ; .)
    BEGIN           reduce using rule 17 (locals -> var_decl ; .)


state 38

    (16) locals -> locals function . ;
    (21) locals -> locals function .

    ;               shift and go to state 59
    ID              reduce using rule 21 (locals -> locals function .)
    FUN             reduce using rule 21 (locals -> locals function .)
    BEGIN           reduce using rule 21 (locals -> locals function .)


state 39

    (15) locals -> locals var_decl . ;
    (19) locals -> locals var_decl .

    ;               shift and go to state 60
    ID              reduce using rule 19 (locals -> locals var_decl .)
    FUN             reduce using rule 19 (locals -> locals var_decl .)
    BEGIN           reduce using rule 19 (locals -> locals var_decl .)


state 40

    (27) type_specifier -> simple_type [ INTEGER . ]

    ]               shift and go to state 61


state 41

    (5) function -> FUN ID ( arglist ) localslist . BEGIN statementBlock END
    (7) function -> FUN ID ( arglist ) localslist . BEGIN statementBlock ; END

    BEGIN           shift and go to state 62


state 42

    (6) function -> FUN ( arglist ) localslist BEGIN statementBlock . END
    (30) statementBlock -> statementBlock . ; statement
    (32) statementBlock -> statementBlock . statement
    (33) statement -> . WHILE relation DO statement
    (34) statement -> . ifthen
    (35) statement -> . ifthenelse
    (36) statement -> . location ASIGN expression
    (37) statement -> . inOutExpr
    (38) statement -> . RETURN expression
    (39) statement -> . RETURN
    (40) statement -> . functionCall
    (41) statement -> . SKIP
    (42) statement -> . BREAK
    (43) statement -> . BEGIN statementBlock END
    (44) statement -> . BEGIN END
    (45) ifthen -> . IF relation THEN statement
    (46) ifthenelse -> . IF relation THEN statement ELSE statement
    (47) ifthenelse -> . IF relation statement ELSE statement
    (56) location -> . ID
    (57) location -> . ID [ expression ]
    (53) inOutExpr -> . PRINT ( STRING )
    (54) inOutExpr -> . WRITE ( expression )
    (55) inOutExpr -> . READ ( location )
    (48) functionCall -> . ID ( paramslistop )

    END             shift and go to state 65
    ;               shift and go to state 64
    WHILE           shift and go to state 47
    RETURN          shift and go to state 43
    SKIP            shift and go to state 53
    BREAK           shift and go to state 58
    BEGIN           shift and go to state 49
    IF              shift and go to state 57
    ID              shift and go to state 56
    PRINT           shift and go to state 46
    WRITE           shift and go to state 54
    READ            shift and go to state 44

    ifthenelse                     shift and go to state 52
    inOutExpr                      shift and go to state 45
    location                       shift and go to state 50
    statement                      shift and go to state 63
    functionCall                   shift and go to state 55
    ifthen                         shift and go to state 48

state 43

    (38) statement -> RETURN . expression
    (39) statement -> RETURN .
    (70) expression -> . expression + expression
    (71) expression -> . expression - expression
    (72) expression -> . expression * expression
    (73) expression -> . expression / expression
    (74) expression -> . - expression
    (75) expression -> . + expression
    (76) expression -> . ( expression )
    (77) expression -> . ID
    (78) expression -> . number
    (79) expression -> . ID [ expression ]
    (80) expression -> . casting
    (81) expression -> . functionCall
    (84) number -> . INTEGER
    (85) number -> . FLOATNUM
    (82) casting -> . INT ( expression )
    (83) casting -> . FLOAT ( expression )
    (48) functionCall -> . ID ( paramslistop )

  ! shift/reduce conflict for ID resolved as shift
    END             reduce using rule 39 (statement -> RETURN .)
    ;               reduce using rule 39 (statement -> RETURN .)
    WHILE           reduce using rule 39 (statement -> RETURN .)
    RETURN          reduce using rule 39 (statement -> RETURN .)
    SKIP            reduce using rule 39 (statement -> RETURN .)
    BREAK           reduce using rule 39 (statement -> RETURN .)
    BEGIN           reduce using rule 39 (statement -> RETURN .)
    IF              reduce using rule 39 (statement -> RETURN .)
    PRINT           reduce using rule 39 (statement -> RETURN .)
    WRITE           reduce using rule 39 (statement -> RETURN .)
    READ            reduce using rule 39 (statement -> RETURN .)
    ELSE            reduce using rule 39 (statement -> RETURN .)
    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 67
    ID              shift and go to state 77
    INTEGER         shift and go to state 74
    FLOATNUM        shift and go to state 73
    INT             shift and go to state 71
    FLOAT           shift and go to state 66

  ! ID              [ reduce using rule 39 (statement -> RETURN .) ]

    functionCall                   shift and go to state 72
    casting                        shift and go to state 75
    expression                     shift and go to state 76
    number                         shift and go to state 70

state 44

    (55) inOutExpr -> READ . ( location )

    (               shift and go to state 78


state 45

    (37) statement -> inOutExpr .

    END             reduce using rule 37 (statement -> inOutExpr .)
    ;               reduce using rule 37 (statement -> inOutExpr .)
    WHILE           reduce using rule 37 (statement -> inOutExpr .)
    RETURN          reduce using rule 37 (statement -> inOutExpr .)
    SKIP            reduce using rule 37 (statement -> inOutExpr .)
    BREAK           reduce using rule 37 (statement -> inOutExpr .)
    BEGIN           reduce using rule 37 (statement -> inOutExpr .)
    IF              reduce using rule 37 (statement -> inOutExpr .)
    ID              reduce using rule 37 (statement -> inOutExpr .)
    PRINT           reduce using rule 37 (statement -> inOutExpr .)
    WRITE           reduce using rule 37 (statement -> inOutExpr .)
    READ            reduce using rule 37 (statement -> inOutExpr .)
    ELSE            reduce using rule 37 (statement -> inOutExpr .)


state 46

    (53) inOutExpr -> PRINT . ( STRING )

    (               shift and go to state 79


state 47

    (33) statement -> WHILE . relation DO statement
    (58) relation -> . relation OR relation
    (59) relation -> . relation AND relation
    (60) relation -> . NOT relation
    (61) relation -> . ( relation )
    (62) relation -> . expression LT expression
    (63) relation -> . expression LE expression
    (64) relation -> . expression GT expression
    (65) relation -> . expression GE expression
    (66) relation -> . expression NE expression
    (67) relation -> . expression EQUAL expression
    (68) relation -> . TRUE
    (69) relation -> . FALSE
    (70) expression -> . expression + expression
    (71) expression -> . expression - expression
    (72) expression -> . expression * expression
    (73) expression -> . expression / expression
    (74) expression -> . - expression
    (75) expression -> . + expression
    (76) expression -> . ( expression )
    (77) expression -> . ID
    (78) expression -> . number
    (79) expression -> . ID [ expression ]
    (80) expression -> . casting
    (81) expression -> . functionCall
    (84) number -> . INTEGER
    (85) number -> . FLOATNUM
    (82) casting -> . INT ( expression )
    (83) casting -> . FLOAT ( expression )
    (48) functionCall -> . ID ( paramslistop )

    NOT             shift and go to state 84
    (               shift and go to state 82
    TRUE            shift and go to state 81
    FALSE           shift and go to state 83
    -               shift and go to state 69
    +               shift and go to state 68
    ID              shift and go to state 77
    INTEGER         shift and go to state 74
    FLOATNUM        shift and go to state 73
    INT             shift and go to state 71
    FLOAT           shift and go to state 66

    casting                        shift and go to state 75
    number                         shift and go to state 70
    functionCall                   shift and go to state 72
    relation                       shift and go to state 80
    expression                     shift and go to state 85

state 48

    (34) statement -> ifthen .

    END             reduce using rule 34 (statement -> ifthen .)
    ;               reduce using rule 34 (statement -> ifthen .)
    WHILE           reduce using rule 34 (statement -> ifthen .)
    RETURN          reduce using rule 34 (statement -> ifthen .)
    SKIP            reduce using rule 34 (statement -> ifthen .)
    BREAK           reduce using rule 34 (statement -> ifthen .)
    BEGIN           reduce using rule 34 (statement -> ifthen .)
    IF              reduce using rule 34 (statement -> ifthen .)
    ID              reduce using rule 34 (statement -> ifthen .)
    PRINT           reduce using rule 34 (statement -> ifthen .)
    WRITE           reduce using rule 34 (statement -> ifthen .)
    READ            reduce using rule 34 (statement -> ifthen .)
    ELSE            reduce using rule 34 (statement -> ifthen .)


state 49

    (43) statement -> BEGIN . statementBlock END
    (44) statement -> BEGIN . END
    (30) statementBlock -> . statementBlock ; statement
    (31) statementBlock -> . statement
    (32) statementBlock -> . statementBlock statement
    (33) statement -> . WHILE relation DO statement
    (34) statement -> . ifthen
    (35) statement -> . ifthenelse
    (36) statement -> . location ASIGN expression
    (37) statement -> . inOutExpr
    (38) statement -> . RETURN expression
    (39) statement -> . RETURN
    (40) statement -> . functionCall
    (41) statement -> . SKIP
    (42) statement -> . BREAK
    (43) statement -> . BEGIN statementBlock END
    (44) statement -> . BEGIN END
    (45) ifthen -> . IF relation THEN statement
    (46) ifthenelse -> . IF relation THEN statement ELSE statement
    (47) ifthenelse -> . IF relation statement ELSE statement
    (56) location -> . ID
    (57) location -> . ID [ expression ]
    (53) inOutExpr -> . PRINT ( STRING )
    (54) inOutExpr -> . WRITE ( expression )
    (55) inOutExpr -> . READ ( location )
    (48) functionCall -> . ID ( paramslistop )

    END             shift and go to state 87
    WHILE           shift and go to state 47
    RETURN          shift and go to state 43
    SKIP            shift and go to state 53
    BREAK           shift and go to state 58
    BEGIN           shift and go to state 49
    IF              shift and go to state 57
    ID              shift and go to state 56
    PRINT           shift and go to state 46
    WRITE           shift and go to state 54
    READ            shift and go to state 44

    statementBlock                 shift and go to state 86
    ifthenelse                     shift and go to state 52
    inOutExpr                      shift and go to state 45
    location                       shift and go to state 50
    statement                      shift and go to state 51
    functionCall                   shift and go to state 55
    ifthen                         shift and go to state 48

state 50

    (36) statement -> location . ASIGN expression

    ASIGN           shift and go to state 88


state 51

    (31) statementBlock -> statement .

    END             reduce using rule 31 (statementBlock -> statement .)
    ;               reduce using rule 31 (statementBlock -> statement .)
    WHILE           reduce using rule 31 (statementBlock -> statement .)
    RETURN          reduce using rule 31 (statementBlock -> statement .)
    SKIP            reduce using rule 31 (statementBlock -> statement .)
    BREAK           reduce using rule 31 (statementBlock -> statement .)
    BEGIN           reduce using rule 31 (statementBlock -> statement .)
    IF              reduce using rule 31 (statementBlock -> statement .)
    ID              reduce using rule 31 (statementBlock -> statement .)
    PRINT           reduce using rule 31 (statementBlock -> statement .)
    WRITE           reduce using rule 31 (statementBlock -> statement .)
    READ            reduce using rule 31 (statementBlock -> statement .)


state 52

    (35) statement -> ifthenelse .

    END             reduce using rule 35 (statement -> ifthenelse .)
    ;               reduce using rule 35 (statement -> ifthenelse .)
    WHILE           reduce using rule 35 (statement -> ifthenelse .)
    RETURN          reduce using rule 35 (statement -> ifthenelse .)
    SKIP            reduce using rule 35 (statement -> ifthenelse .)
    BREAK           reduce using rule 35 (statement -> ifthenelse .)
    BEGIN           reduce using rule 35 (statement -> ifthenelse .)
    IF              reduce using rule 35 (statement -> ifthenelse .)
    ID              reduce using rule 35 (statement -> ifthenelse .)
    PRINT           reduce using rule 35 (statement -> ifthenelse .)
    WRITE           reduce using rule 35 (statement -> ifthenelse .)
    READ            reduce using rule 35 (statement -> ifthenelse .)
    ELSE            reduce using rule 35 (statement -> ifthenelse .)


state 53

    (41) statement -> SKIP .

    END             reduce using rule 41 (statement -> SKIP .)
    ;               reduce using rule 41 (statement -> SKIP .)
    WHILE           reduce using rule 41 (statement -> SKIP .)
    RETURN          reduce using rule 41 (statement -> SKIP .)
    SKIP            reduce using rule 41 (statement -> SKIP .)
    BREAK           reduce using rule 41 (statement -> SKIP .)
    BEGIN           reduce using rule 41 (statement -> SKIP .)
    IF              reduce using rule 41 (statement -> SKIP .)
    ID              reduce using rule 41 (statement -> SKIP .)
    PRINT           reduce using rule 41 (statement -> SKIP .)
    WRITE           reduce using rule 41 (statement -> SKIP .)
    READ            reduce using rule 41 (statement -> SKIP .)
    ELSE            reduce using rule 41 (statement -> SKIP .)


state 54

    (54) inOutExpr -> WRITE . ( expression )

    (               shift and go to state 89


state 55

    (40) statement -> functionCall .

    END             reduce using rule 40 (statement -> functionCall .)
    ;               reduce using rule 40 (statement -> functionCall .)
    WHILE           reduce using rule 40 (statement -> functionCall .)
    RETURN          reduce using rule 40 (statement -> functionCall .)
    SKIP            reduce using rule 40 (statement -> functionCall .)
    BREAK           reduce using rule 40 (statement -> functionCall .)
    BEGIN           reduce using rule 40 (statement -> functionCall .)
    IF              reduce using rule 40 (statement -> functionCall .)
    ID              reduce using rule 40 (statement -> functionCall .)
    PRINT           reduce using rule 40 (statement -> functionCall .)
    WRITE           reduce using rule 40 (statement -> functionCall .)
    READ            reduce using rule 40 (statement -> functionCall .)
    ELSE            reduce using rule 40 (statement -> functionCall .)


state 56

    (56) location -> ID .
    (57) location -> ID . [ expression ]
    (48) functionCall -> ID . ( paramslistop )

    ASIGN           reduce using rule 56 (location -> ID .)
    [               shift and go to state 91
    (               shift and go to state 90


state 57

    (45) ifthen -> IF . relation THEN statement
    (46) ifthenelse -> IF . relation THEN statement ELSE statement
    (47) ifthenelse -> IF . relation statement ELSE statement
    (58) relation -> . relation OR relation
    (59) relation -> . relation AND relation
    (60) relation -> . NOT relation
    (61) relation -> . ( relation )
    (62) relation -> . expression LT expression
    (63) relation -> . expression LE expression
    (64) relation -> . expression GT expression
    (65) relation -> . expression GE expression
    (66) relation -> . expression NE expression
    (67) relation -> . expression EQUAL expression
    (68) relation -> . TRUE
    (69) relation -> . FALSE
    (70) expression -> . expression + expression
    (71) expression -> . expression - expression
    (72) expression -> . expression * expression
    (73) expression -> . expression / expression
    (74) expression -> . - expression
    (75) expression -> . + expression
    (76) expression -> . ( expression )
    (77) expression -> . ID
    (78) expression -> . number
    (79) expression -> . ID [ expression ]
    (80) expression -> . casting
    (81) expression -> . functionCall
    (84) number -> . INTEGER
    (85) number -> . FLOATNUM
    (82) casting -> . INT ( expression )
    (83) casting -> . FLOAT ( expression )
    (48) functionCall -> . ID ( paramslistop )

    NOT             shift and go to state 84
    (               shift and go to state 82
    TRUE            shift and go to state 81
    FALSE           shift and go to state 83
    -               shift and go to state 69
    +               shift and go to state 68
    ID              shift and go to state 77
    INTEGER         shift and go to state 74
    FLOATNUM        shift and go to state 73
    INT             shift and go to state 71
    FLOAT           shift and go to state 66

    casting                        shift and go to state 75
    number                         shift and go to state 70
    functionCall                   shift and go to state 72
    relation                       shift and go to state 92
    expression                     shift and go to state 85

state 58

    (42) statement -> BREAK .

    END             reduce using rule 42 (statement -> BREAK .)
    ;               reduce using rule 42 (statement -> BREAK .)
    WHILE           reduce using rule 42 (statement -> BREAK .)
    RETURN          reduce using rule 42 (statement -> BREAK .)
    SKIP            reduce using rule 42 (statement -> BREAK .)
    BREAK           reduce using rule 42 (statement -> BREAK .)
    BEGIN           reduce using rule 42 (statement -> BREAK .)
    IF              reduce using rule 42 (statement -> BREAK .)
    ID              reduce using rule 42 (statement -> BREAK .)
    PRINT           reduce using rule 42 (statement -> BREAK .)
    WRITE           reduce using rule 42 (statement -> BREAK .)
    READ            reduce using rule 42 (statement -> BREAK .)
    ELSE            reduce using rule 42 (statement -> BREAK .)


state 59

    (16) locals -> locals function ; .

    ID              reduce using rule 16 (locals -> locals function ; .)
    FUN             reduce using rule 16 (locals -> locals function ; .)
    BEGIN           reduce using rule 16 (locals -> locals function ; .)


state 60

    (15) locals -> locals var_decl ; .

    ID              reduce using rule 15 (locals -> locals var_decl ; .)
    FUN             reduce using rule 15 (locals -> locals var_decl ; .)
    BEGIN           reduce using rule 15 (locals -> locals var_decl ; .)


state 61

    (27) type_specifier -> simple_type [ INTEGER ] .

    ,               reduce using rule 27 (type_specifier -> simple_type [ INTEGER ] .)
    ID              reduce using rule 27 (type_specifier -> simple_type [ INTEGER ] .)
    )               reduce using rule 27 (type_specifier -> simple_type [ INTEGER ] .)
    ;               reduce using rule 27 (type_specifier -> simple_type [ INTEGER ] .)
    FUN             reduce using rule 27 (type_specifier -> simple_type [ INTEGER ] .)
    BEGIN           reduce using rule 27 (type_specifier -> simple_type [ INTEGER ] .)


state 62

    (5) function -> FUN ID ( arglist ) localslist BEGIN . statementBlock END
    (7) function -> FUN ID ( arglist ) localslist BEGIN . statementBlock ; END
    (30) statementBlock -> . statementBlock ; statement
    (31) statementBlock -> . statement
    (32) statementBlock -> . statementBlock statement
    (33) statement -> . WHILE relation DO statement
    (34) statement -> . ifthen
    (35) statement -> . ifthenelse
    (36) statement -> . location ASIGN expression
    (37) statement -> . inOutExpr
    (38) statement -> . RETURN expression
    (39) statement -> . RETURN
    (40) statement -> . functionCall
    (41) statement -> . SKIP
    (42) statement -> . BREAK
    (43) statement -> . BEGIN statementBlock END
    (44) statement -> . BEGIN END
    (45) ifthen -> . IF relation THEN statement
    (46) ifthenelse -> . IF relation THEN statement ELSE statement
    (47) ifthenelse -> . IF relation statement ELSE statement
    (56) location -> . ID
    (57) location -> . ID [ expression ]
    (53) inOutExpr -> . PRINT ( STRING )
    (54) inOutExpr -> . WRITE ( expression )
    (55) inOutExpr -> . READ ( location )
    (48) functionCall -> . ID ( paramslistop )

    WHILE           shift and go to state 47
    RETURN          shift and go to state 43
    SKIP            shift and go to state 53
    BREAK           shift and go to state 58
    BEGIN           shift and go to state 49
    IF              shift and go to state 57
    ID              shift and go to state 56
    PRINT           shift and go to state 46
    WRITE           shift and go to state 54
    READ            shift and go to state 44

    statementBlock                 shift and go to state 93
    ifthenelse                     shift and go to state 52
    inOutExpr                      shift and go to state 45
    location                       shift and go to state 50
    statement                      shift and go to state 51
    functionCall                   shift and go to state 55
    ifthen                         shift and go to state 48

state 63

    (32) statementBlock -> statementBlock statement .

    END             reduce using rule 32 (statementBlock -> statementBlock statement .)
    ;               reduce using rule 32 (statementBlock -> statementBlock statement .)
    WHILE           reduce using rule 32 (statementBlock -> statementBlock statement .)
    RETURN          reduce using rule 32 (statementBlock -> statementBlock statement .)
    SKIP            reduce using rule 32 (statementBlock -> statementBlock statement .)
    BREAK           reduce using rule 32 (statementBlock -> statementBlock statement .)
    BEGIN           reduce using rule 32 (statementBlock -> statementBlock statement .)
    IF              reduce using rule 32 (statementBlock -> statementBlock statement .)
    ID              reduce using rule 32 (statementBlock -> statementBlock statement .)
    PRINT           reduce using rule 32 (statementBlock -> statementBlock statement .)
    WRITE           reduce using rule 32 (statementBlock -> statementBlock statement .)
    READ            reduce using rule 32 (statementBlock -> statementBlock statement .)


state 64

    (30) statementBlock -> statementBlock ; . statement
    (33) statement -> . WHILE relation DO statement
    (34) statement -> . ifthen
    (35) statement -> . ifthenelse
    (36) statement -> . location ASIGN expression
    (37) statement -> . inOutExpr
    (38) statement -> . RETURN expression
    (39) statement -> . RETURN
    (40) statement -> . functionCall
    (41) statement -> . SKIP
    (42) statement -> . BREAK
    (43) statement -> . BEGIN statementBlock END
    (44) statement -> . BEGIN END
    (45) ifthen -> . IF relation THEN statement
    (46) ifthenelse -> . IF relation THEN statement ELSE statement
    (47) ifthenelse -> . IF relation statement ELSE statement
    (56) location -> . ID
    (57) location -> . ID [ expression ]
    (53) inOutExpr -> . PRINT ( STRING )
    (54) inOutExpr -> . WRITE ( expression )
    (55) inOutExpr -> . READ ( location )
    (48) functionCall -> . ID ( paramslistop )

    WHILE           shift and go to state 47
    RETURN          shift and go to state 43
    SKIP            shift and go to state 53
    BREAK           shift and go to state 58
    BEGIN           shift and go to state 49
    IF              shift and go to state 57
    ID              shift and go to state 56
    PRINT           shift and go to state 46
    WRITE           shift and go to state 54
    READ            shift and go to state 44

    ifthenelse                     shift and go to state 52
    inOutExpr                      shift and go to state 45
    location                       shift and go to state 50
    statement                      shift and go to state 94
    functionCall                   shift and go to state 55
    ifthen                         shift and go to state 48

state 65

    (6) function -> FUN ( arglist ) localslist BEGIN statementBlock END .

    ;               reduce using rule 6 (function -> FUN ( arglist ) localslist BEGIN statementBlock END .)
    ID              reduce using rule 6 (function -> FUN ( arglist ) localslist BEGIN statementBlock END .)
    FUN             reduce using rule 6 (function -> FUN ( arglist ) localslist BEGIN statementBlock END .)
    BEGIN           reduce using rule 6 (function -> FUN ( arglist ) localslist BEGIN statementBlock END .)
    $end            reduce using rule 6 (function -> FUN ( arglist ) localslist BEGIN statementBlock END .)


state 66

    (83) casting -> FLOAT . ( expression )

    (               shift and go to state 95


state 67

    (76) expression -> ( . expression )
    (70) expression -> . expression + expression
    (71) expression -> . expression - expression
    (72) expression -> . expression * expression
    (73) expression -> . expression / expression
    (74) expression -> . - expression
    (75) expression -> . + expression
    (76) expression -> . ( expression )
    (77) expression -> . ID
    (78) expression -> . number
    (79) expression -> . ID [ expression ]
    (80) expression -> . casting
    (81) expression -> . functionCall
    (84) number -> . INTEGER
    (85) number -> . FLOATNUM
    (82) casting -> . INT ( expression )
    (83) casting -> . FLOAT ( expression )
    (48) functionCall -> . ID ( paramslistop )

    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 67
    ID              shift and go to state 77
    INTEGER         shift and go to state 74
    FLOATNUM        shift and go to state 73
    INT             shift and go to state 71
    FLOAT           shift and go to state 66

    functionCall                   shift and go to state 72
    casting                        shift and go to state 75
    expression                     shift and go to state 96
    number                         shift and go to state 70

state 68

    (75) expression -> + . expression
    (70) expression -> . expression + expression
    (71) expression -> . expression - expression
    (72) expression -> . expression * expression
    (73) expression -> . expression / expression
    (74) expression -> . - expression
    (75) expression -> . + expression
    (76) expression -> . ( expression )
    (77) expression -> . ID
    (78) expression -> . number
    (79) expression -> . ID [ expression ]
    (80) expression -> . casting
    (81) expression -> . functionCall
    (84) number -> . INTEGER
    (85) number -> . FLOATNUM
    (82) casting -> . INT ( expression )
    (83) casting -> . FLOAT ( expression )
    (48) functionCall -> . ID ( paramslistop )

    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 67
    ID              shift and go to state 77
    INTEGER         shift and go to state 74
    FLOATNUM        shift and go to state 73
    INT             shift and go to state 71
    FLOAT           shift and go to state 66

    functionCall                   shift and go to state 72
    casting                        shift and go to state 75
    expression                     shift and go to state 97
    number                         shift and go to state 70

state 69

    (74) expression -> - . expression
    (70) expression -> . expression + expression
    (71) expression -> . expression - expression
    (72) expression -> . expression * expression
    (73) expression -> . expression / expression
    (74) expression -> . - expression
    (75) expression -> . + expression
    (76) expression -> . ( expression )
    (77) expression -> . ID
    (78) expression -> . number
    (79) expression -> . ID [ expression ]
    (80) expression -> . casting
    (81) expression -> . functionCall
    (84) number -> . INTEGER
    (85) number -> . FLOATNUM
    (82) casting -> . INT ( expression )
    (83) casting -> . FLOAT ( expression )
    (48) functionCall -> . ID ( paramslistop )

    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 67
    ID              shift and go to state 77
    INTEGER         shift and go to state 74
    FLOATNUM        shift and go to state 73
    INT             shift and go to state 71
    FLOAT           shift and go to state 66

    functionCall                   shift and go to state 72
    casting                        shift and go to state 75
    expression                     shift and go to state 98
    number                         shift and go to state 70

state 70

    (78) expression -> number .

    LT              reduce using rule 78 (expression -> number .)
    LE              reduce using rule 78 (expression -> number .)
    GT              reduce using rule 78 (expression -> number .)
    GE              reduce using rule 78 (expression -> number .)
    NE              reduce using rule 78 (expression -> number .)
    EQUAL           reduce using rule 78 (expression -> number .)
    +               reduce using rule 78 (expression -> number .)
    -               reduce using rule 78 (expression -> number .)
    *               reduce using rule 78 (expression -> number .)
    /               reduce using rule 78 (expression -> number .)
    ]               reduce using rule 78 (expression -> number .)
    END             reduce using rule 78 (expression -> number .)
    ;               reduce using rule 78 (expression -> number .)
    WHILE           reduce using rule 78 (expression -> number .)
    RETURN          reduce using rule 78 (expression -> number .)
    SKIP            reduce using rule 78 (expression -> number .)
    BREAK           reduce using rule 78 (expression -> number .)
    BEGIN           reduce using rule 78 (expression -> number .)
    IF              reduce using rule 78 (expression -> number .)
    ID              reduce using rule 78 (expression -> number .)
    PRINT           reduce using rule 78 (expression -> number .)
    WRITE           reduce using rule 78 (expression -> number .)
    READ            reduce using rule 78 (expression -> number .)
    ELSE            reduce using rule 78 (expression -> number .)
    )               reduce using rule 78 (expression -> number .)
    ,               reduce using rule 78 (expression -> number .)
    DO              reduce using rule 78 (expression -> number .)
    OR              reduce using rule 78 (expression -> number .)
    AND             reduce using rule 78 (expression -> number .)
    THEN            reduce using rule 78 (expression -> number .)


state 71

    (82) casting -> INT . ( expression )

    (               shift and go to state 99


state 72

    (81) expression -> functionCall .

    LT              reduce using rule 81 (expression -> functionCall .)
    LE              reduce using rule 81 (expression -> functionCall .)
    GT              reduce using rule 81 (expression -> functionCall .)
    GE              reduce using rule 81 (expression -> functionCall .)
    NE              reduce using rule 81 (expression -> functionCall .)
    EQUAL           reduce using rule 81 (expression -> functionCall .)
    +               reduce using rule 81 (expression -> functionCall .)
    -               reduce using rule 81 (expression -> functionCall .)
    *               reduce using rule 81 (expression -> functionCall .)
    /               reduce using rule 81 (expression -> functionCall .)
    ]               reduce using rule 81 (expression -> functionCall .)
    END             reduce using rule 81 (expression -> functionCall .)
    ;               reduce using rule 81 (expression -> functionCall .)
    WHILE           reduce using rule 81 (expression -> functionCall .)
    RETURN          reduce using rule 81 (expression -> functionCall .)
    SKIP            reduce using rule 81 (expression -> functionCall .)
    BREAK           reduce using rule 81 (expression -> functionCall .)
    BEGIN           reduce using rule 81 (expression -> functionCall .)
    IF              reduce using rule 81 (expression -> functionCall .)
    ID              reduce using rule 81 (expression -> functionCall .)
    PRINT           reduce using rule 81 (expression -> functionCall .)
    WRITE           reduce using rule 81 (expression -> functionCall .)
    READ            reduce using rule 81 (expression -> functionCall .)
    ELSE            reduce using rule 81 (expression -> functionCall .)
    )               reduce using rule 81 (expression -> functionCall .)
    ,               reduce using rule 81 (expression -> functionCall .)
    DO              reduce using rule 81 (expression -> functionCall .)
    OR              reduce using rule 81 (expression -> functionCall .)
    AND             reduce using rule 81 (expression -> functionCall .)
    THEN            reduce using rule 81 (expression -> functionCall .)


state 73

    (85) number -> FLOATNUM .

    +               reduce using rule 85 (number -> FLOATNUM .)
    -               reduce using rule 85 (number -> FLOATNUM .)
    *               reduce using rule 85 (number -> FLOATNUM .)
    /               reduce using rule 85 (number -> FLOATNUM .)
    ,               reduce using rule 85 (number -> FLOATNUM .)
    )               reduce using rule 85 (number -> FLOATNUM .)
    DO              reduce using rule 85 (number -> FLOATNUM .)
    OR              reduce using rule 85 (number -> FLOATNUM .)
    AND             reduce using rule 85 (number -> FLOATNUM .)
    THEN            reduce using rule 85 (number -> FLOATNUM .)
    WHILE           reduce using rule 85 (number -> FLOATNUM .)
    RETURN          reduce using rule 85 (number -> FLOATNUM .)
    SKIP            reduce using rule 85 (number -> FLOATNUM .)
    BREAK           reduce using rule 85 (number -> FLOATNUM .)
    BEGIN           reduce using rule 85 (number -> FLOATNUM .)
    IF              reduce using rule 85 (number -> FLOATNUM .)
    ID              reduce using rule 85 (number -> FLOATNUM .)
    PRINT           reduce using rule 85 (number -> FLOATNUM .)
    WRITE           reduce using rule 85 (number -> FLOATNUM .)
    READ            reduce using rule 85 (number -> FLOATNUM .)
    END             reduce using rule 85 (number -> FLOATNUM .)
    ;               reduce using rule 85 (number -> FLOATNUM .)
    ELSE            reduce using rule 85 (number -> FLOATNUM .)
    LT              reduce using rule 85 (number -> FLOATNUM .)
    LE              reduce using rule 85 (number -> FLOATNUM .)
    GT              reduce using rule 85 (number -> FLOATNUM .)
    GE              reduce using rule 85 (number -> FLOATNUM .)
    NE              reduce using rule 85 (number -> FLOATNUM .)
    EQUAL           reduce using rule 85 (number -> FLOATNUM .)
    ]               reduce using rule 85 (number -> FLOATNUM .)


state 74

    (84) number -> INTEGER .

    +               reduce using rule 84 (number -> INTEGER .)
    -               reduce using rule 84 (number -> INTEGER .)
    *               reduce using rule 84 (number -> INTEGER .)
    /               reduce using rule 84 (number -> INTEGER .)
    ,               reduce using rule 84 (number -> INTEGER .)
    )               reduce using rule 84 (number -> INTEGER .)
    DO              reduce using rule 84 (number -> INTEGER .)
    OR              reduce using rule 84 (number -> INTEGER .)
    AND             reduce using rule 84 (number -> INTEGER .)
    THEN            reduce using rule 84 (number -> INTEGER .)
    WHILE           reduce using rule 84 (number -> INTEGER .)
    RETURN          reduce using rule 84 (number -> INTEGER .)
    SKIP            reduce using rule 84 (number -> INTEGER .)
    BREAK           reduce using rule 84 (number -> INTEGER .)
    BEGIN           reduce using rule 84 (number -> INTEGER .)
    IF              reduce using rule 84 (number -> INTEGER .)
    ID              reduce using rule 84 (number -> INTEGER .)
    PRINT           reduce using rule 84 (number -> INTEGER .)
    WRITE           reduce using rule 84 (number -> INTEGER .)
    READ            reduce using rule 84 (number -> INTEGER .)
    END             reduce using rule 84 (number -> INTEGER .)
    ;               reduce using rule 84 (number -> INTEGER .)
    ELSE            reduce using rule 84 (number -> INTEGER .)
    LT              reduce using rule 84 (number -> INTEGER .)
    LE              reduce using rule 84 (number -> INTEGER .)
    GT              reduce using rule 84 (number -> INTEGER .)
    GE              reduce using rule 84 (number -> INTEGER .)
    NE              reduce using rule 84 (number -> INTEGER .)
    EQUAL           reduce using rule 84 (number -> INTEGER .)
    ]               reduce using rule 84 (number -> INTEGER .)


state 75

    (80) expression -> casting .

    LT              reduce using rule 80 (expression -> casting .)
    LE              reduce using rule 80 (expression -> casting .)
    GT              reduce using rule 80 (expression -> casting .)
    GE              reduce using rule 80 (expression -> casting .)
    NE              reduce using rule 80 (expression -> casting .)
    EQUAL           reduce using rule 80 (expression -> casting .)
    +               reduce using rule 80 (expression -> casting .)
    -               reduce using rule 80 (expression -> casting .)
    *               reduce using rule 80 (expression -> casting .)
    /               reduce using rule 80 (expression -> casting .)
    ]               reduce using rule 80 (expression -> casting .)
    END             reduce using rule 80 (expression -> casting .)
    ;               reduce using rule 80 (expression -> casting .)
    WHILE           reduce using rule 80 (expression -> casting .)
    RETURN          reduce using rule 80 (expression -> casting .)
    SKIP            reduce using rule 80 (expression -> casting .)
    BREAK           reduce using rule 80 (expression -> casting .)
    BEGIN           reduce using rule 80 (expression -> casting .)
    IF              reduce using rule 80 (expression -> casting .)
    ID              reduce using rule 80 (expression -> casting .)
    PRINT           reduce using rule 80 (expression -> casting .)
    WRITE           reduce using rule 80 (expression -> casting .)
    READ            reduce using rule 80 (expression -> casting .)
    ELSE            reduce using rule 80 (expression -> casting .)
    )               reduce using rule 80 (expression -> casting .)
    ,               reduce using rule 80 (expression -> casting .)
    DO              reduce using rule 80 (expression -> casting .)
    OR              reduce using rule 80 (expression -> casting .)
    AND             reduce using rule 80 (expression -> casting .)
    THEN            reduce using rule 80 (expression -> casting .)


state 76

    (38) statement -> RETURN expression .
    (70) expression -> expression . + expression
    (71) expression -> expression . - expression
    (72) expression -> expression . * expression
    (73) expression -> expression . / expression

    END             reduce using rule 38 (statement -> RETURN expression .)
    ;               reduce using rule 38 (statement -> RETURN expression .)
    WHILE           reduce using rule 38 (statement -> RETURN expression .)
    RETURN          reduce using rule 38 (statement -> RETURN expression .)
    SKIP            reduce using rule 38 (statement -> RETURN expression .)
    BREAK           reduce using rule 38 (statement -> RETURN expression .)
    BEGIN           reduce using rule 38 (statement -> RETURN expression .)
    IF              reduce using rule 38 (statement -> RETURN expression .)
    ID              reduce using rule 38 (statement -> RETURN expression .)
    PRINT           reduce using rule 38 (statement -> RETURN expression .)
    WRITE           reduce using rule 38 (statement -> RETURN expression .)
    READ            reduce using rule 38 (statement -> RETURN expression .)
    ELSE            reduce using rule 38 (statement -> RETURN expression .)
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103


state 77

    (77) expression -> ID .
    (79) expression -> ID . [ expression ]
    (48) functionCall -> ID . ( paramslistop )

    LT              reduce using rule 77 (expression -> ID .)
    LE              reduce using rule 77 (expression -> ID .)
    GT              reduce using rule 77 (expression -> ID .)
    GE              reduce using rule 77 (expression -> ID .)
    NE              reduce using rule 77 (expression -> ID .)
    EQUAL           reduce using rule 77 (expression -> ID .)
    +               reduce using rule 77 (expression -> ID .)
    -               reduce using rule 77 (expression -> ID .)
    *               reduce using rule 77 (expression -> ID .)
    /               reduce using rule 77 (expression -> ID .)
    ]               reduce using rule 77 (expression -> ID .)
    END             reduce using rule 77 (expression -> ID .)
    ;               reduce using rule 77 (expression -> ID .)
    WHILE           reduce using rule 77 (expression -> ID .)
    RETURN          reduce using rule 77 (expression -> ID .)
    SKIP            reduce using rule 77 (expression -> ID .)
    BREAK           reduce using rule 77 (expression -> ID .)
    BEGIN           reduce using rule 77 (expression -> ID .)
    IF              reduce using rule 77 (expression -> ID .)
    ID              reduce using rule 77 (expression -> ID .)
    PRINT           reduce using rule 77 (expression -> ID .)
    WRITE           reduce using rule 77 (expression -> ID .)
    READ            reduce using rule 77 (expression -> ID .)
    ELSE            reduce using rule 77 (expression -> ID .)
    )               reduce using rule 77 (expression -> ID .)
    ,               reduce using rule 77 (expression -> ID .)
    DO              reduce using rule 77 (expression -> ID .)
    OR              reduce using rule 77 (expression -> ID .)
    AND             reduce using rule 77 (expression -> ID .)
    THEN            reduce using rule 77 (expression -> ID .)
    [               shift and go to state 104
    (               shift and go to state 90


state 78

    (55) inOutExpr -> READ ( . location )
    (56) location -> . ID
    (57) location -> . ID [ expression ]

    ID              shift and go to state 106

    location                       shift and go to state 105

state 79

    (53) inOutExpr -> PRINT ( . STRING )

    STRING          shift and go to state 107


state 80

    (33) statement -> WHILE relation . DO statement
    (58) relation -> relation . OR relation
    (59) relation -> relation . AND relation

    DO              shift and go to state 109
    OR              shift and go to state 110
    AND             shift and go to state 108


state 81

    (68) relation -> TRUE .

    THEN            reduce using rule 68 (relation -> TRUE .)
    OR              reduce using rule 68 (relation -> TRUE .)
    AND             reduce using rule 68 (relation -> TRUE .)
    WHILE           reduce using rule 68 (relation -> TRUE .)
    RETURN          reduce using rule 68 (relation -> TRUE .)
    SKIP            reduce using rule 68 (relation -> TRUE .)
    BREAK           reduce using rule 68 (relation -> TRUE .)
    BEGIN           reduce using rule 68 (relation -> TRUE .)
    IF              reduce using rule 68 (relation -> TRUE .)
    ID              reduce using rule 68 (relation -> TRUE .)
    PRINT           reduce using rule 68 (relation -> TRUE .)
    WRITE           reduce using rule 68 (relation -> TRUE .)
    READ            reduce using rule 68 (relation -> TRUE .)
    DO              reduce using rule 68 (relation -> TRUE .)
    )               reduce using rule 68 (relation -> TRUE .)


state 82

    (61) relation -> ( . relation )
    (76) expression -> ( . expression )
    (58) relation -> . relation OR relation
    (59) relation -> . relation AND relation
    (60) relation -> . NOT relation
    (61) relation -> . ( relation )
    (62) relation -> . expression LT expression
    (63) relation -> . expression LE expression
    (64) relation -> . expression GT expression
    (65) relation -> . expression GE expression
    (66) relation -> . expression NE expression
    (67) relation -> . expression EQUAL expression
    (68) relation -> . TRUE
    (69) relation -> . FALSE
    (70) expression -> . expression + expression
    (71) expression -> . expression - expression
    (72) expression -> . expression * expression
    (73) expression -> . expression / expression
    (74) expression -> . - expression
    (75) expression -> . + expression
    (76) expression -> . ( expression )
    (77) expression -> . ID
    (78) expression -> . number
    (79) expression -> . ID [ expression ]
    (80) expression -> . casting
    (81) expression -> . functionCall
    (84) number -> . INTEGER
    (85) number -> . FLOATNUM
    (82) casting -> . INT ( expression )
    (83) casting -> . FLOAT ( expression )
    (48) functionCall -> . ID ( paramslistop )

    NOT             shift and go to state 84
    (               shift and go to state 82
    TRUE            shift and go to state 81
    FALSE           shift and go to state 83
    -               shift and go to state 69
    +               shift and go to state 68
    ID              shift and go to state 77
    INTEGER         shift and go to state 74
    FLOATNUM        shift and go to state 73
    INT             shift and go to state 71
    FLOAT           shift and go to state 66

    casting                        shift and go to state 75
    number                         shift and go to state 70
    relation                       shift and go to state 111
    functionCall                   shift and go to state 72
    expression                     shift and go to state 112

state 83

    (69) relation -> FALSE .

    THEN            reduce using rule 69 (relation -> FALSE .)
    OR              reduce using rule 69 (relation -> FALSE .)
    AND             reduce using rule 69 (relation -> FALSE .)
    WHILE           reduce using rule 69 (relation -> FALSE .)
    RETURN          reduce using rule 69 (relation -> FALSE .)
    SKIP            reduce using rule 69 (relation -> FALSE .)
    BREAK           reduce using rule 69 (relation -> FALSE .)
    BEGIN           reduce using rule 69 (relation -> FALSE .)
    IF              reduce using rule 69 (relation -> FALSE .)
    ID              reduce using rule 69 (relation -> FALSE .)
    PRINT           reduce using rule 69 (relation -> FALSE .)
    WRITE           reduce using rule 69 (relation -> FALSE .)
    READ            reduce using rule 69 (relation -> FALSE .)
    DO              reduce using rule 69 (relation -> FALSE .)
    )               reduce using rule 69 (relation -> FALSE .)


state 84

    (60) relation -> NOT . relation
    (58) relation -> . relation OR relation
    (59) relation -> . relation AND relation
    (60) relation -> . NOT relation
    (61) relation -> . ( relation )
    (62) relation -> . expression LT expression
    (63) relation -> . expression LE expression
    (64) relation -> . expression GT expression
    (65) relation -> . expression GE expression
    (66) relation -> . expression NE expression
    (67) relation -> . expression EQUAL expression
    (68) relation -> . TRUE
    (69) relation -> . FALSE
    (70) expression -> . expression + expression
    (71) expression -> . expression - expression
    (72) expression -> . expression * expression
    (73) expression -> . expression / expression
    (74) expression -> . - expression
    (75) expression -> . + expression
    (76) expression -> . ( expression )
    (77) expression -> . ID
    (78) expression -> . number
    (79) expression -> . ID [ expression ]
    (80) expression -> . casting
    (81) expression -> . functionCall
    (84) number -> . INTEGER
    (85) number -> . FLOATNUM
    (82) casting -> . INT ( expression )
    (83) casting -> . FLOAT ( expression )
    (48) functionCall -> . ID ( paramslistop )

    NOT             shift and go to state 84
    (               shift and go to state 82
    TRUE            shift and go to state 81
    FALSE           shift and go to state 83
    -               shift and go to state 69
    +               shift and go to state 68
    ID              shift and go to state 77
    INTEGER         shift and go to state 74
    FLOATNUM        shift and go to state 73
    INT             shift and go to state 71
    FLOAT           shift and go to state 66

    casting                        shift and go to state 75
    number                         shift and go to state 70
    relation                       shift and go to state 113
    functionCall                   shift and go to state 72
    expression                     shift and go to state 85

state 85

    (62) relation -> expression . LT expression
    (63) relation -> expression . LE expression
    (64) relation -> expression . GT expression
    (65) relation -> expression . GE expression
    (66) relation -> expression . NE expression
    (67) relation -> expression . EQUAL expression
    (70) expression -> expression . + expression
    (71) expression -> expression . - expression
    (72) expression -> expression . * expression
    (73) expression -> expression . / expression

    LT              shift and go to state 118
    LE              shift and go to state 114
    GT              shift and go to state 119
    GE              shift and go to state 116
    NE              shift and go to state 117
    EQUAL           shift and go to state 115
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103


state 86

    (43) statement -> BEGIN statementBlock . END
    (30) statementBlock -> statementBlock . ; statement
    (32) statementBlock -> statementBlock . statement
    (33) statement -> . WHILE relation DO statement
    (34) statement -> . ifthen
    (35) statement -> . ifthenelse
    (36) statement -> . location ASIGN expression
    (37) statement -> . inOutExpr
    (38) statement -> . RETURN expression
    (39) statement -> . RETURN
    (40) statement -> . functionCall
    (41) statement -> . SKIP
    (42) statement -> . BREAK
    (43) statement -> . BEGIN statementBlock END
    (44) statement -> . BEGIN END
    (45) ifthen -> . IF relation THEN statement
    (46) ifthenelse -> . IF relation THEN statement ELSE statement
    (47) ifthenelse -> . IF relation statement ELSE statement
    (56) location -> . ID
    (57) location -> . ID [ expression ]
    (53) inOutExpr -> . PRINT ( STRING )
    (54) inOutExpr -> . WRITE ( expression )
    (55) inOutExpr -> . READ ( location )
    (48) functionCall -> . ID ( paramslistop )

    END             shift and go to state 120
    ;               shift and go to state 64
    WHILE           shift and go to state 47
    RETURN          shift and go to state 43
    SKIP            shift and go to state 53
    BREAK           shift and go to state 58
    BEGIN           shift and go to state 49
    IF              shift and go to state 57
    ID              shift and go to state 56
    PRINT           shift and go to state 46
    WRITE           shift and go to state 54
    READ            shift and go to state 44

    ifthenelse                     shift and go to state 52
    inOutExpr                      shift and go to state 45
    location                       shift and go to state 50
    statement                      shift and go to state 63
    functionCall                   shift and go to state 55
    ifthen                         shift and go to state 48

state 87

    (44) statement -> BEGIN END .

    END             reduce using rule 44 (statement -> BEGIN END .)
    ;               reduce using rule 44 (statement -> BEGIN END .)
    WHILE           reduce using rule 44 (statement -> BEGIN END .)
    RETURN          reduce using rule 44 (statement -> BEGIN END .)
    SKIP            reduce using rule 44 (statement -> BEGIN END .)
    BREAK           reduce using rule 44 (statement -> BEGIN END .)
    BEGIN           reduce using rule 44 (statement -> BEGIN END .)
    IF              reduce using rule 44 (statement -> BEGIN END .)
    ID              reduce using rule 44 (statement -> BEGIN END .)
    PRINT           reduce using rule 44 (statement -> BEGIN END .)
    WRITE           reduce using rule 44 (statement -> BEGIN END .)
    READ            reduce using rule 44 (statement -> BEGIN END .)
    ELSE            reduce using rule 44 (statement -> BEGIN END .)


state 88

    (36) statement -> location ASIGN . expression
    (70) expression -> . expression + expression
    (71) expression -> . expression - expression
    (72) expression -> . expression * expression
    (73) expression -> . expression / expression
    (74) expression -> . - expression
    (75) expression -> . + expression
    (76) expression -> . ( expression )
    (77) expression -> . ID
    (78) expression -> . number
    (79) expression -> . ID [ expression ]
    (80) expression -> . casting
    (81) expression -> . functionCall
    (84) number -> . INTEGER
    (85) number -> . FLOATNUM
    (82) casting -> . INT ( expression )
    (83) casting -> . FLOAT ( expression )
    (48) functionCall -> . ID ( paramslistop )

    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 67
    ID              shift and go to state 77
    INTEGER         shift and go to state 74
    FLOATNUM        shift and go to state 73
    INT             shift and go to state 71
    FLOAT           shift and go to state 66

    casting                        shift and go to state 75
    number                         shift and go to state 70
    functionCall                   shift and go to state 72
    expression                     shift and go to state 121

state 89

    (54) inOutExpr -> WRITE ( . expression )
    (70) expression -> . expression + expression
    (71) expression -> . expression - expression
    (72) expression -> . expression * expression
    (73) expression -> . expression / expression
    (74) expression -> . - expression
    (75) expression -> . + expression
    (76) expression -> . ( expression )
    (77) expression -> . ID
    (78) expression -> . number
    (79) expression -> . ID [ expression ]
    (80) expression -> . casting
    (81) expression -> . functionCall
    (84) number -> . INTEGER
    (85) number -> . FLOATNUM
    (82) casting -> . INT ( expression )
    (83) casting -> . FLOAT ( expression )
    (48) functionCall -> . ID ( paramslistop )

    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 67
    ID              shift and go to state 77
    INTEGER         shift and go to state 74
    FLOATNUM        shift and go to state 73
    INT             shift and go to state 71
    FLOAT           shift and go to state 66

    functionCall                   shift and go to state 72
    casting                        shift and go to state 75
    expression                     shift and go to state 122
    number                         shift and go to state 70

state 90

    (48) functionCall -> ID ( . paramslistop )
    (49) paramslistop -> . paramList
    (50) paramslistop -> . empty
    (51) paramList -> . paramList , expression
    (52) paramList -> . expression
    (86) empty -> .
    (70) expression -> . expression + expression
    (71) expression -> . expression - expression
    (72) expression -> . expression * expression
    (73) expression -> . expression / expression
    (74) expression -> . - expression
    (75) expression -> . + expression
    (76) expression -> . ( expression )
    (77) expression -> . ID
    (78) expression -> . number
    (79) expression -> . ID [ expression ]
    (80) expression -> . casting
    (81) expression -> . functionCall
    (84) number -> . INTEGER
    (85) number -> . FLOATNUM
    (82) casting -> . INT ( expression )
    (83) casting -> . FLOAT ( expression )
    (48) functionCall -> . ID ( paramslistop )

    )               reduce using rule 86 (empty -> .)
    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 67
    ID              shift and go to state 77
    INTEGER         shift and go to state 74
    FLOATNUM        shift and go to state 73
    INT             shift and go to state 71
    FLOAT           shift and go to state 66

    casting                        shift and go to state 75
    paramslistop                   shift and go to state 123
    number                         shift and go to state 70
    functionCall                   shift and go to state 72
    paramList                      shift and go to state 124
    expression                     shift and go to state 125
    empty                          shift and go to state 126

state 91

    (57) location -> ID [ . expression ]
    (70) expression -> . expression + expression
    (71) expression -> . expression - expression
    (72) expression -> . expression * expression
    (73) expression -> . expression / expression
    (74) expression -> . - expression
    (75) expression -> . + expression
    (76) expression -> . ( expression )
    (77) expression -> . ID
    (78) expression -> . number
    (79) expression -> . ID [ expression ]
    (80) expression -> . casting
    (81) expression -> . functionCall
    (84) number -> . INTEGER
    (85) number -> . FLOATNUM
    (82) casting -> . INT ( expression )
    (83) casting -> . FLOAT ( expression )
    (48) functionCall -> . ID ( paramslistop )

    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 67
    ID              shift and go to state 77
    INTEGER         shift and go to state 74
    FLOATNUM        shift and go to state 73
    INT             shift and go to state 71
    FLOAT           shift and go to state 66

    functionCall                   shift and go to state 72
    casting                        shift and go to state 75
    expression                     shift and go to state 127
    number                         shift and go to state 70

state 92

    (45) ifthen -> IF relation . THEN statement
    (46) ifthenelse -> IF relation . THEN statement ELSE statement
    (47) ifthenelse -> IF relation . statement ELSE statement
    (58) relation -> relation . OR relation
    (59) relation -> relation . AND relation
    (33) statement -> . WHILE relation DO statement
    (34) statement -> . ifthen
    (35) statement -> . ifthenelse
    (36) statement -> . location ASIGN expression
    (37) statement -> . inOutExpr
    (38) statement -> . RETURN expression
    (39) statement -> . RETURN
    (40) statement -> . functionCall
    (41) statement -> . SKIP
    (42) statement -> . BREAK
    (43) statement -> . BEGIN statementBlock END
    (44) statement -> . BEGIN END
    (45) ifthen -> . IF relation THEN statement
    (46) ifthenelse -> . IF relation THEN statement ELSE statement
    (47) ifthenelse -> . IF relation statement ELSE statement
    (56) location -> . ID
    (57) location -> . ID [ expression ]
    (53) inOutExpr -> . PRINT ( STRING )
    (54) inOutExpr -> . WRITE ( expression )
    (55) inOutExpr -> . READ ( location )
    (48) functionCall -> . ID ( paramslistop )

    THEN            shift and go to state 128
    OR              shift and go to state 110
    AND             shift and go to state 108
    WHILE           shift and go to state 47
    RETURN          shift and go to state 43
    SKIP            shift and go to state 53
    BREAK           shift and go to state 58
    BEGIN           shift and go to state 49
    IF              shift and go to state 57
    ID              shift and go to state 56
    PRINT           shift and go to state 46
    WRITE           shift and go to state 54
    READ            shift and go to state 44

    ifthenelse                     shift and go to state 52
    inOutExpr                      shift and go to state 45
    location                       shift and go to state 50
    statement                      shift and go to state 129
    functionCall                   shift and go to state 55
    ifthen                         shift and go to state 48

state 93

    (5) function -> FUN ID ( arglist ) localslist BEGIN statementBlock . END
    (7) function -> FUN ID ( arglist ) localslist BEGIN statementBlock . ; END
    (30) statementBlock -> statementBlock . ; statement
    (32) statementBlock -> statementBlock . statement
    (33) statement -> . WHILE relation DO statement
    (34) statement -> . ifthen
    (35) statement -> . ifthenelse
    (36) statement -> . location ASIGN expression
    (37) statement -> . inOutExpr
    (38) statement -> . RETURN expression
    (39) statement -> . RETURN
    (40) statement -> . functionCall
    (41) statement -> . SKIP
    (42) statement -> . BREAK
    (43) statement -> . BEGIN statementBlock END
    (44) statement -> . BEGIN END
    (45) ifthen -> . IF relation THEN statement
    (46) ifthenelse -> . IF relation THEN statement ELSE statement
    (47) ifthenelse -> . IF relation statement ELSE statement
    (56) location -> . ID
    (57) location -> . ID [ expression ]
    (53) inOutExpr -> . PRINT ( STRING )
    (54) inOutExpr -> . WRITE ( expression )
    (55) inOutExpr -> . READ ( location )
    (48) functionCall -> . ID ( paramslistop )

    END             shift and go to state 131
    ;               shift and go to state 130
    WHILE           shift and go to state 47
    RETURN          shift and go to state 43
    SKIP            shift and go to state 53
    BREAK           shift and go to state 58
    BEGIN           shift and go to state 49
    IF              shift and go to state 57
    ID              shift and go to state 56
    PRINT           shift and go to state 46
    WRITE           shift and go to state 54
    READ            shift and go to state 44

    ifthenelse                     shift and go to state 52
    inOutExpr                      shift and go to state 45
    location                       shift and go to state 50
    statement                      shift and go to state 63
    functionCall                   shift and go to state 55
    ifthen                         shift and go to state 48

state 94

    (30) statementBlock -> statementBlock ; statement .

    END             reduce using rule 30 (statementBlock -> statementBlock ; statement .)
    ;               reduce using rule 30 (statementBlock -> statementBlock ; statement .)
    WHILE           reduce using rule 30 (statementBlock -> statementBlock ; statement .)
    RETURN          reduce using rule 30 (statementBlock -> statementBlock ; statement .)
    SKIP            reduce using rule 30 (statementBlock -> statementBlock ; statement .)
    BREAK           reduce using rule 30 (statementBlock -> statementBlock ; statement .)
    BEGIN           reduce using rule 30 (statementBlock -> statementBlock ; statement .)
    IF              reduce using rule 30 (statementBlock -> statementBlock ; statement .)
    ID              reduce using rule 30 (statementBlock -> statementBlock ; statement .)
    PRINT           reduce using rule 30 (statementBlock -> statementBlock ; statement .)
    WRITE           reduce using rule 30 (statementBlock -> statementBlock ; statement .)
    READ            reduce using rule 30 (statementBlock -> statementBlock ; statement .)


state 95

    (83) casting -> FLOAT ( . expression )
    (70) expression -> . expression + expression
    (71) expression -> . expression - expression
    (72) expression -> . expression * expression
    (73) expression -> . expression / expression
    (74) expression -> . - expression
    (75) expression -> . + expression
    (76) expression -> . ( expression )
    (77) expression -> . ID
    (78) expression -> . number
    (79) expression -> . ID [ expression ]
    (80) expression -> . casting
    (81) expression -> . functionCall
    (84) number -> . INTEGER
    (85) number -> . FLOATNUM
    (82) casting -> . INT ( expression )
    (83) casting -> . FLOAT ( expression )
    (48) functionCall -> . ID ( paramslistop )

    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 67
    ID              shift and go to state 77
    INTEGER         shift and go to state 74
    FLOATNUM        shift and go to state 73
    INT             shift and go to state 71
    FLOAT           shift and go to state 66

    functionCall                   shift and go to state 72
    casting                        shift and go to state 75
    expression                     shift and go to state 132
    number                         shift and go to state 70

state 96

    (76) expression -> ( expression . )
    (70) expression -> expression . + expression
    (71) expression -> expression . - expression
    (72) expression -> expression . * expression
    (73) expression -> expression . / expression

    )               shift and go to state 133
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103


state 97

    (75) expression -> + expression .
    (70) expression -> expression . + expression
    (71) expression -> expression . - expression
    (72) expression -> expression . * expression
    (73) expression -> expression . / expression

    LT              reduce using rule 75 (expression -> + expression .)
    LE              reduce using rule 75 (expression -> + expression .)
    GT              reduce using rule 75 (expression -> + expression .)
    GE              reduce using rule 75 (expression -> + expression .)
    NE              reduce using rule 75 (expression -> + expression .)
    EQUAL           reduce using rule 75 (expression -> + expression .)
    +               reduce using rule 75 (expression -> + expression .)
    -               reduce using rule 75 (expression -> + expression .)
    *               reduce using rule 75 (expression -> + expression .)
    /               reduce using rule 75 (expression -> + expression .)
    ]               reduce using rule 75 (expression -> + expression .)
    END             reduce using rule 75 (expression -> + expression .)
    ;               reduce using rule 75 (expression -> + expression .)
    WHILE           reduce using rule 75 (expression -> + expression .)
    RETURN          reduce using rule 75 (expression -> + expression .)
    SKIP            reduce using rule 75 (expression -> + expression .)
    BREAK           reduce using rule 75 (expression -> + expression .)
    BEGIN           reduce using rule 75 (expression -> + expression .)
    IF              reduce using rule 75 (expression -> + expression .)
    ID              reduce using rule 75 (expression -> + expression .)
    PRINT           reduce using rule 75 (expression -> + expression .)
    WRITE           reduce using rule 75 (expression -> + expression .)
    READ            reduce using rule 75 (expression -> + expression .)
    ELSE            reduce using rule 75 (expression -> + expression .)
    )               reduce using rule 75 (expression -> + expression .)
    ,               reduce using rule 75 (expression -> + expression .)
    DO              reduce using rule 75 (expression -> + expression .)
    OR              reduce using rule 75 (expression -> + expression .)
    AND             reduce using rule 75 (expression -> + expression .)
    THEN            reduce using rule 75 (expression -> + expression .)

  ! +               [ shift and go to state 100 ]
  ! -               [ shift and go to state 102 ]
  ! *               [ shift and go to state 101 ]
  ! /               [ shift and go to state 103 ]


state 98

    (74) expression -> - expression .
    (70) expression -> expression . + expression
    (71) expression -> expression . - expression
    (72) expression -> expression . * expression
    (73) expression -> expression . / expression

    LT              reduce using rule 74 (expression -> - expression .)
    LE              reduce using rule 74 (expression -> - expression .)
    GT              reduce using rule 74 (expression -> - expression .)
    GE              reduce using rule 74 (expression -> - expression .)
    NE              reduce using rule 74 (expression -> - expression .)
    EQUAL           reduce using rule 74 (expression -> - expression .)
    +               reduce using rule 74 (expression -> - expression .)
    -               reduce using rule 74 (expression -> - expression .)
    *               reduce using rule 74 (expression -> - expression .)
    /               reduce using rule 74 (expression -> - expression .)
    ]               reduce using rule 74 (expression -> - expression .)
    END             reduce using rule 74 (expression -> - expression .)
    ;               reduce using rule 74 (expression -> - expression .)
    WHILE           reduce using rule 74 (expression -> - expression .)
    RETURN          reduce using rule 74 (expression -> - expression .)
    SKIP            reduce using rule 74 (expression -> - expression .)
    BREAK           reduce using rule 74 (expression -> - expression .)
    BEGIN           reduce using rule 74 (expression -> - expression .)
    IF              reduce using rule 74 (expression -> - expression .)
    ID              reduce using rule 74 (expression -> - expression .)
    PRINT           reduce using rule 74 (expression -> - expression .)
    WRITE           reduce using rule 74 (expression -> - expression .)
    READ            reduce using rule 74 (expression -> - expression .)
    ELSE            reduce using rule 74 (expression -> - expression .)
    )               reduce using rule 74 (expression -> - expression .)
    ,               reduce using rule 74 (expression -> - expression .)
    DO              reduce using rule 74 (expression -> - expression .)
    OR              reduce using rule 74 (expression -> - expression .)
    AND             reduce using rule 74 (expression -> - expression .)
    THEN            reduce using rule 74 (expression -> - expression .)

  ! +               [ shift and go to state 100 ]
  ! -               [ shift and go to state 102 ]
  ! *               [ shift and go to state 101 ]
  ! /               [ shift and go to state 103 ]


state 99

    (82) casting -> INT ( . expression )
    (70) expression -> . expression + expression
    (71) expression -> . expression - expression
    (72) expression -> . expression * expression
    (73) expression -> . expression / expression
    (74) expression -> . - expression
    (75) expression -> . + expression
    (76) expression -> . ( expression )
    (77) expression -> . ID
    (78) expression -> . number
    (79) expression -> . ID [ expression ]
    (80) expression -> . casting
    (81) expression -> . functionCall
    (84) number -> . INTEGER
    (85) number -> . FLOATNUM
    (82) casting -> . INT ( expression )
    (83) casting -> . FLOAT ( expression )
    (48) functionCall -> . ID ( paramslistop )

    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 67
    ID              shift and go to state 77
    INTEGER         shift and go to state 74
    FLOATNUM        shift and go to state 73
    INT             shift and go to state 71
    FLOAT           shift and go to state 66

    functionCall                   shift and go to state 72
    casting                        shift and go to state 75
    expression                     shift and go to state 134
    number                         shift and go to state 70

state 100

    (70) expression -> expression + . expression
    (70) expression -> . expression + expression
    (71) expression -> . expression - expression
    (72) expression -> . expression * expression
    (73) expression -> . expression / expression
    (74) expression -> . - expression
    (75) expression -> . + expression
    (76) expression -> . ( expression )
    (77) expression -> . ID
    (78) expression -> . number
    (79) expression -> . ID [ expression ]
    (80) expression -> . casting
    (81) expression -> . functionCall
    (84) number -> . INTEGER
    (85) number -> . FLOATNUM
    (82) casting -> . INT ( expression )
    (83) casting -> . FLOAT ( expression )
    (48) functionCall -> . ID ( paramslistop )

    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 67
    ID              shift and go to state 77
    INTEGER         shift and go to state 74
    FLOATNUM        shift and go to state 73
    INT             shift and go to state 71
    FLOAT           shift and go to state 66

    functionCall                   shift and go to state 72
    casting                        shift and go to state 75
    expression                     shift and go to state 135
    number                         shift and go to state 70

state 101

    (72) expression -> expression * . expression
    (70) expression -> . expression + expression
    (71) expression -> . expression - expression
    (72) expression -> . expression * expression
    (73) expression -> . expression / expression
    (74) expression -> . - expression
    (75) expression -> . + expression
    (76) expression -> . ( expression )
    (77) expression -> . ID
    (78) expression -> . number
    (79) expression -> . ID [ expression ]
    (80) expression -> . casting
    (81) expression -> . functionCall
    (84) number -> . INTEGER
    (85) number -> . FLOATNUM
    (82) casting -> . INT ( expression )
    (83) casting -> . FLOAT ( expression )
    (48) functionCall -> . ID ( paramslistop )

    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 67
    ID              shift and go to state 77
    INTEGER         shift and go to state 74
    FLOATNUM        shift and go to state 73
    INT             shift and go to state 71
    FLOAT           shift and go to state 66

    functionCall                   shift and go to state 72
    casting                        shift and go to state 75
    expression                     shift and go to state 136
    number                         shift and go to state 70

state 102

    (71) expression -> expression - . expression
    (70) expression -> . expression + expression
    (71) expression -> . expression - expression
    (72) expression -> . expression * expression
    (73) expression -> . expression / expression
    (74) expression -> . - expression
    (75) expression -> . + expression
    (76) expression -> . ( expression )
    (77) expression -> . ID
    (78) expression -> . number
    (79) expression -> . ID [ expression ]
    (80) expression -> . casting
    (81) expression -> . functionCall
    (84) number -> . INTEGER
    (85) number -> . FLOATNUM
    (82) casting -> . INT ( expression )
    (83) casting -> . FLOAT ( expression )
    (48) functionCall -> . ID ( paramslistop )

    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 67
    ID              shift and go to state 77
    INTEGER         shift and go to state 74
    FLOATNUM        shift and go to state 73
    INT             shift and go to state 71
    FLOAT           shift and go to state 66

    functionCall                   shift and go to state 72
    casting                        shift and go to state 75
    expression                     shift and go to state 137
    number                         shift and go to state 70

state 103

    (73) expression -> expression / . expression
    (70) expression -> . expression + expression
    (71) expression -> . expression - expression
    (72) expression -> . expression * expression
    (73) expression -> . expression / expression
    (74) expression -> . - expression
    (75) expression -> . + expression
    (76) expression -> . ( expression )
    (77) expression -> . ID
    (78) expression -> . number
    (79) expression -> . ID [ expression ]
    (80) expression -> . casting
    (81) expression -> . functionCall
    (84) number -> . INTEGER
    (85) number -> . FLOATNUM
    (82) casting -> . INT ( expression )
    (83) casting -> . FLOAT ( expression )
    (48) functionCall -> . ID ( paramslistop )

    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 67
    ID              shift and go to state 77
    INTEGER         shift and go to state 74
    FLOATNUM        shift and go to state 73
    INT             shift and go to state 71
    FLOAT           shift and go to state 66

    functionCall                   shift and go to state 72
    casting                        shift and go to state 75
    expression                     shift and go to state 138
    number                         shift and go to state 70

state 104

    (79) expression -> ID [ . expression ]
    (70) expression -> . expression + expression
    (71) expression -> . expression - expression
    (72) expression -> . expression * expression
    (73) expression -> . expression / expression
    (74) expression -> . - expression
    (75) expression -> . + expression
    (76) expression -> . ( expression )
    (77) expression -> . ID
    (78) expression -> . number
    (79) expression -> . ID [ expression ]
    (80) expression -> . casting
    (81) expression -> . functionCall
    (84) number -> . INTEGER
    (85) number -> . FLOATNUM
    (82) casting -> . INT ( expression )
    (83) casting -> . FLOAT ( expression )
    (48) functionCall -> . ID ( paramslistop )

    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 67
    ID              shift and go to state 77
    INTEGER         shift and go to state 74
    FLOATNUM        shift and go to state 73
    INT             shift and go to state 71
    FLOAT           shift and go to state 66

    functionCall                   shift and go to state 72
    casting                        shift and go to state 75
    expression                     shift and go to state 139
    number                         shift and go to state 70

state 105

    (55) inOutExpr -> READ ( location . )

    )               shift and go to state 140


state 106

    (56) location -> ID .
    (57) location -> ID . [ expression ]

    )               reduce using rule 56 (location -> ID .)
    [               shift and go to state 91


state 107

    (53) inOutExpr -> PRINT ( STRING . )

    )               shift and go to state 141


state 108

    (59) relation -> relation AND . relation
    (58) relation -> . relation OR relation
    (59) relation -> . relation AND relation
    (60) relation -> . NOT relation
    (61) relation -> . ( relation )
    (62) relation -> . expression LT expression
    (63) relation -> . expression LE expression
    (64) relation -> . expression GT expression
    (65) relation -> . expression GE expression
    (66) relation -> . expression NE expression
    (67) relation -> . expression EQUAL expression
    (68) relation -> . TRUE
    (69) relation -> . FALSE
    (70) expression -> . expression + expression
    (71) expression -> . expression - expression
    (72) expression -> . expression * expression
    (73) expression -> . expression / expression
    (74) expression -> . - expression
    (75) expression -> . + expression
    (76) expression -> . ( expression )
    (77) expression -> . ID
    (78) expression -> . number
    (79) expression -> . ID [ expression ]
    (80) expression -> . casting
    (81) expression -> . functionCall
    (84) number -> . INTEGER
    (85) number -> . FLOATNUM
    (82) casting -> . INT ( expression )
    (83) casting -> . FLOAT ( expression )
    (48) functionCall -> . ID ( paramslistop )

    NOT             shift and go to state 84
    (               shift and go to state 82
    TRUE            shift and go to state 81
    FALSE           shift and go to state 83
    -               shift and go to state 69
    +               shift and go to state 68
    ID              shift and go to state 77
    INTEGER         shift and go to state 74
    FLOATNUM        shift and go to state 73
    INT             shift and go to state 71
    FLOAT           shift and go to state 66

    casting                        shift and go to state 75
    number                         shift and go to state 70
    relation                       shift and go to state 142
    functionCall                   shift and go to state 72
    expression                     shift and go to state 85

state 109

    (33) statement -> WHILE relation DO . statement
    (33) statement -> . WHILE relation DO statement
    (34) statement -> . ifthen
    (35) statement -> . ifthenelse
    (36) statement -> . location ASIGN expression
    (37) statement -> . inOutExpr
    (38) statement -> . RETURN expression
    (39) statement -> . RETURN
    (40) statement -> . functionCall
    (41) statement -> . SKIP
    (42) statement -> . BREAK
    (43) statement -> . BEGIN statementBlock END
    (44) statement -> . BEGIN END
    (45) ifthen -> . IF relation THEN statement
    (46) ifthenelse -> . IF relation THEN statement ELSE statement
    (47) ifthenelse -> . IF relation statement ELSE statement
    (56) location -> . ID
    (57) location -> . ID [ expression ]
    (53) inOutExpr -> . PRINT ( STRING )
    (54) inOutExpr -> . WRITE ( expression )
    (55) inOutExpr -> . READ ( location )
    (48) functionCall -> . ID ( paramslistop )

    WHILE           shift and go to state 47
    RETURN          shift and go to state 43
    SKIP            shift and go to state 53
    BREAK           shift and go to state 58
    BEGIN           shift and go to state 49
    IF              shift and go to state 57
    ID              shift and go to state 56
    PRINT           shift and go to state 46
    WRITE           shift and go to state 54
    READ            shift and go to state 44

    ifthenelse                     shift and go to state 52
    inOutExpr                      shift and go to state 45
    location                       shift and go to state 50
    statement                      shift and go to state 143
    functionCall                   shift and go to state 55
    ifthen                         shift and go to state 48

state 110

    (58) relation -> relation OR . relation
    (58) relation -> . relation OR relation
    (59) relation -> . relation AND relation
    (60) relation -> . NOT relation
    (61) relation -> . ( relation )
    (62) relation -> . expression LT expression
    (63) relation -> . expression LE expression
    (64) relation -> . expression GT expression
    (65) relation -> . expression GE expression
    (66) relation -> . expression NE expression
    (67) relation -> . expression EQUAL expression
    (68) relation -> . TRUE
    (69) relation -> . FALSE
    (70) expression -> . expression + expression
    (71) expression -> . expression - expression
    (72) expression -> . expression * expression
    (73) expression -> . expression / expression
    (74) expression -> . - expression
    (75) expression -> . + expression
    (76) expression -> . ( expression )
    (77) expression -> . ID
    (78) expression -> . number
    (79) expression -> . ID [ expression ]
    (80) expression -> . casting
    (81) expression -> . functionCall
    (84) number -> . INTEGER
    (85) number -> . FLOATNUM
    (82) casting -> . INT ( expression )
    (83) casting -> . FLOAT ( expression )
    (48) functionCall -> . ID ( paramslistop )

    NOT             shift and go to state 84
    (               shift and go to state 82
    TRUE            shift and go to state 81
    FALSE           shift and go to state 83
    -               shift and go to state 69
    +               shift and go to state 68
    ID              shift and go to state 77
    INTEGER         shift and go to state 74
    FLOATNUM        shift and go to state 73
    INT             shift and go to state 71
    FLOAT           shift and go to state 66

    casting                        shift and go to state 75
    number                         shift and go to state 70
    relation                       shift and go to state 144
    functionCall                   shift and go to state 72
    expression                     shift and go to state 85

state 111

    (61) relation -> ( relation . )
    (58) relation -> relation . OR relation
    (59) relation -> relation . AND relation

    )               shift and go to state 145
    OR              shift and go to state 110
    AND             shift and go to state 108


state 112

    (76) expression -> ( expression . )
    (62) relation -> expression . LT expression
    (63) relation -> expression . LE expression
    (64) relation -> expression . GT expression
    (65) relation -> expression . GE expression
    (66) relation -> expression . NE expression
    (67) relation -> expression . EQUAL expression
    (70) expression -> expression . + expression
    (71) expression -> expression . - expression
    (72) expression -> expression . * expression
    (73) expression -> expression . / expression

    )               shift and go to state 133
    LT              shift and go to state 118
    LE              shift and go to state 114
    GT              shift and go to state 119
    GE              shift and go to state 116
    NE              shift and go to state 117
    EQUAL           shift and go to state 115
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103


state 113

    (60) relation -> NOT relation .
    (58) relation -> relation . OR relation
    (59) relation -> relation . AND relation

    THEN            reduce using rule 60 (relation -> NOT relation .)
    OR              reduce using rule 60 (relation -> NOT relation .)
    AND             reduce using rule 60 (relation -> NOT relation .)
    WHILE           reduce using rule 60 (relation -> NOT relation .)
    RETURN          reduce using rule 60 (relation -> NOT relation .)
    SKIP            reduce using rule 60 (relation -> NOT relation .)
    BREAK           reduce using rule 60 (relation -> NOT relation .)
    BEGIN           reduce using rule 60 (relation -> NOT relation .)
    IF              reduce using rule 60 (relation -> NOT relation .)
    ID              reduce using rule 60 (relation -> NOT relation .)
    PRINT           reduce using rule 60 (relation -> NOT relation .)
    WRITE           reduce using rule 60 (relation -> NOT relation .)
    READ            reduce using rule 60 (relation -> NOT relation .)
    DO              reduce using rule 60 (relation -> NOT relation .)
    )               reduce using rule 60 (relation -> NOT relation .)

  ! OR              [ shift and go to state 110 ]
  ! AND             [ shift and go to state 108 ]


state 114

    (63) relation -> expression LE . expression
    (70) expression -> . expression + expression
    (71) expression -> . expression - expression
    (72) expression -> . expression * expression
    (73) expression -> . expression / expression
    (74) expression -> . - expression
    (75) expression -> . + expression
    (76) expression -> . ( expression )
    (77) expression -> . ID
    (78) expression -> . number
    (79) expression -> . ID [ expression ]
    (80) expression -> . casting
    (81) expression -> . functionCall
    (84) number -> . INTEGER
    (85) number -> . FLOATNUM
    (82) casting -> . INT ( expression )
    (83) casting -> . FLOAT ( expression )
    (48) functionCall -> . ID ( paramslistop )

    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 67
    ID              shift and go to state 77
    INTEGER         shift and go to state 74
    FLOATNUM        shift and go to state 73
    INT             shift and go to state 71
    FLOAT           shift and go to state 66

    functionCall                   shift and go to state 72
    casting                        shift and go to state 75
    expression                     shift and go to state 146
    number                         shift and go to state 70

state 115

    (67) relation -> expression EQUAL . expression
    (70) expression -> . expression + expression
    (71) expression -> . expression - expression
    (72) expression -> . expression * expression
    (73) expression -> . expression / expression
    (74) expression -> . - expression
    (75) expression -> . + expression
    (76) expression -> . ( expression )
    (77) expression -> . ID
    (78) expression -> . number
    (79) expression -> . ID [ expression ]
    (80) expression -> . casting
    (81) expression -> . functionCall
    (84) number -> . INTEGER
    (85) number -> . FLOATNUM
    (82) casting -> . INT ( expression )
    (83) casting -> . FLOAT ( expression )
    (48) functionCall -> . ID ( paramslistop )

    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 67
    ID              shift and go to state 77
    INTEGER         shift and go to state 74
    FLOATNUM        shift and go to state 73
    INT             shift and go to state 71
    FLOAT           shift and go to state 66

    functionCall                   shift and go to state 72
    casting                        shift and go to state 75
    expression                     shift and go to state 147
    number                         shift and go to state 70

state 116

    (65) relation -> expression GE . expression
    (70) expression -> . expression + expression
    (71) expression -> . expression - expression
    (72) expression -> . expression * expression
    (73) expression -> . expression / expression
    (74) expression -> . - expression
    (75) expression -> . + expression
    (76) expression -> . ( expression )
    (77) expression -> . ID
    (78) expression -> . number
    (79) expression -> . ID [ expression ]
    (80) expression -> . casting
    (81) expression -> . functionCall
    (84) number -> . INTEGER
    (85) number -> . FLOATNUM
    (82) casting -> . INT ( expression )
    (83) casting -> . FLOAT ( expression )
    (48) functionCall -> . ID ( paramslistop )

    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 67
    ID              shift and go to state 77
    INTEGER         shift and go to state 74
    FLOATNUM        shift and go to state 73
    INT             shift and go to state 71
    FLOAT           shift and go to state 66

    functionCall                   shift and go to state 72
    casting                        shift and go to state 75
    expression                     shift and go to state 148
    number                         shift and go to state 70

state 117

    (66) relation -> expression NE . expression
    (70) expression -> . expression + expression
    (71) expression -> . expression - expression
    (72) expression -> . expression * expression
    (73) expression -> . expression / expression
    (74) expression -> . - expression
    (75) expression -> . + expression
    (76) expression -> . ( expression )
    (77) expression -> . ID
    (78) expression -> . number
    (79) expression -> . ID [ expression ]
    (80) expression -> . casting
    (81) expression -> . functionCall
    (84) number -> . INTEGER
    (85) number -> . FLOATNUM
    (82) casting -> . INT ( expression )
    (83) casting -> . FLOAT ( expression )
    (48) functionCall -> . ID ( paramslistop )

    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 67
    ID              shift and go to state 77
    INTEGER         shift and go to state 74
    FLOATNUM        shift and go to state 73
    INT             shift and go to state 71
    FLOAT           shift and go to state 66

    functionCall                   shift and go to state 72
    casting                        shift and go to state 75
    expression                     shift and go to state 149
    number                         shift and go to state 70

state 118

    (62) relation -> expression LT . expression
    (70) expression -> . expression + expression
    (71) expression -> . expression - expression
    (72) expression -> . expression * expression
    (73) expression -> . expression / expression
    (74) expression -> . - expression
    (75) expression -> . + expression
    (76) expression -> . ( expression )
    (77) expression -> . ID
    (78) expression -> . number
    (79) expression -> . ID [ expression ]
    (80) expression -> . casting
    (81) expression -> . functionCall
    (84) number -> . INTEGER
    (85) number -> . FLOATNUM
    (82) casting -> . INT ( expression )
    (83) casting -> . FLOAT ( expression )
    (48) functionCall -> . ID ( paramslistop )

    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 67
    ID              shift and go to state 77
    INTEGER         shift and go to state 74
    FLOATNUM        shift and go to state 73
    INT             shift and go to state 71
    FLOAT           shift and go to state 66

    functionCall                   shift and go to state 72
    casting                        shift and go to state 75
    expression                     shift and go to state 150
    number                         shift and go to state 70

state 119

    (64) relation -> expression GT . expression
    (70) expression -> . expression + expression
    (71) expression -> . expression - expression
    (72) expression -> . expression * expression
    (73) expression -> . expression / expression
    (74) expression -> . - expression
    (75) expression -> . + expression
    (76) expression -> . ( expression )
    (77) expression -> . ID
    (78) expression -> . number
    (79) expression -> . ID [ expression ]
    (80) expression -> . casting
    (81) expression -> . functionCall
    (84) number -> . INTEGER
    (85) number -> . FLOATNUM
    (82) casting -> . INT ( expression )
    (83) casting -> . FLOAT ( expression )
    (48) functionCall -> . ID ( paramslistop )

    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 67
    ID              shift and go to state 77
    INTEGER         shift and go to state 74
    FLOATNUM        shift and go to state 73
    INT             shift and go to state 71
    FLOAT           shift and go to state 66

    functionCall                   shift and go to state 72
    casting                        shift and go to state 75
    expression                     shift and go to state 151
    number                         shift and go to state 70

state 120

    (43) statement -> BEGIN statementBlock END .

    END             reduce using rule 43 (statement -> BEGIN statementBlock END .)
    ;               reduce using rule 43 (statement -> BEGIN statementBlock END .)
    WHILE           reduce using rule 43 (statement -> BEGIN statementBlock END .)
    RETURN          reduce using rule 43 (statement -> BEGIN statementBlock END .)
    SKIP            reduce using rule 43 (statement -> BEGIN statementBlock END .)
    BREAK           reduce using rule 43 (statement -> BEGIN statementBlock END .)
    BEGIN           reduce using rule 43 (statement -> BEGIN statementBlock END .)
    IF              reduce using rule 43 (statement -> BEGIN statementBlock END .)
    ID              reduce using rule 43 (statement -> BEGIN statementBlock END .)
    PRINT           reduce using rule 43 (statement -> BEGIN statementBlock END .)
    WRITE           reduce using rule 43 (statement -> BEGIN statementBlock END .)
    READ            reduce using rule 43 (statement -> BEGIN statementBlock END .)
    ELSE            reduce using rule 43 (statement -> BEGIN statementBlock END .)


state 121

    (36) statement -> location ASIGN expression .
    (70) expression -> expression . + expression
    (71) expression -> expression . - expression
    (72) expression -> expression . * expression
    (73) expression -> expression . / expression

    END             reduce using rule 36 (statement -> location ASIGN expression .)
    ;               reduce using rule 36 (statement -> location ASIGN expression .)
    WHILE           reduce using rule 36 (statement -> location ASIGN expression .)
    RETURN          reduce using rule 36 (statement -> location ASIGN expression .)
    SKIP            reduce using rule 36 (statement -> location ASIGN expression .)
    BREAK           reduce using rule 36 (statement -> location ASIGN expression .)
    BEGIN           reduce using rule 36 (statement -> location ASIGN expression .)
    IF              reduce using rule 36 (statement -> location ASIGN expression .)
    ID              reduce using rule 36 (statement -> location ASIGN expression .)
    PRINT           reduce using rule 36 (statement -> location ASIGN expression .)
    WRITE           reduce using rule 36 (statement -> location ASIGN expression .)
    READ            reduce using rule 36 (statement -> location ASIGN expression .)
    ELSE            reduce using rule 36 (statement -> location ASIGN expression .)
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103


state 122

    (54) inOutExpr -> WRITE ( expression . )
    (70) expression -> expression . + expression
    (71) expression -> expression . - expression
    (72) expression -> expression . * expression
    (73) expression -> expression . / expression

    )               shift and go to state 152
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103


state 123

    (48) functionCall -> ID ( paramslistop . )

    )               shift and go to state 153


state 124

    (49) paramslistop -> paramList .
    (51) paramList -> paramList . , expression

    )               reduce using rule 49 (paramslistop -> paramList .)
    ,               shift and go to state 154


state 125

    (52) paramList -> expression .
    (70) expression -> expression . + expression
    (71) expression -> expression . - expression
    (72) expression -> expression . * expression
    (73) expression -> expression . / expression

    ,               reduce using rule 52 (paramList -> expression .)
    )               reduce using rule 52 (paramList -> expression .)
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103


state 126

    (50) paramslistop -> empty .

    )               reduce using rule 50 (paramslistop -> empty .)


state 127

    (57) location -> ID [ expression . ]
    (70) expression -> expression . + expression
    (71) expression -> expression . - expression
    (72) expression -> expression . * expression
    (73) expression -> expression . / expression

    ]               shift and go to state 155
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103


state 128

    (45) ifthen -> IF relation THEN . statement
    (46) ifthenelse -> IF relation THEN . statement ELSE statement
    (33) statement -> . WHILE relation DO statement
    (34) statement -> . ifthen
    (35) statement -> . ifthenelse
    (36) statement -> . location ASIGN expression
    (37) statement -> . inOutExpr
    (38) statement -> . RETURN expression
    (39) statement -> . RETURN
    (40) statement -> . functionCall
    (41) statement -> . SKIP
    (42) statement -> . BREAK
    (43) statement -> . BEGIN statementBlock END
    (44) statement -> . BEGIN END
    (45) ifthen -> . IF relation THEN statement
    (46) ifthenelse -> . IF relation THEN statement ELSE statement
    (47) ifthenelse -> . IF relation statement ELSE statement
    (56) location -> . ID
    (57) location -> . ID [ expression ]
    (53) inOutExpr -> . PRINT ( STRING )
    (54) inOutExpr -> . WRITE ( expression )
    (55) inOutExpr -> . READ ( location )
    (48) functionCall -> . ID ( paramslistop )

    WHILE           shift and go to state 47
    RETURN          shift and go to state 43
    SKIP            shift and go to state 53
    BREAK           shift and go to state 58
    BEGIN           shift and go to state 49
    IF              shift and go to state 57
    ID              shift and go to state 56
    PRINT           shift and go to state 46
    WRITE           shift and go to state 54
    READ            shift and go to state 44

    ifthenelse                     shift and go to state 52
    inOutExpr                      shift and go to state 45
    location                       shift and go to state 50
    statement                      shift and go to state 156
    functionCall                   shift and go to state 55
    ifthen                         shift and go to state 48

state 129

    (47) ifthenelse -> IF relation statement . ELSE statement

    ELSE            shift and go to state 157


state 130

    (7) function -> FUN ID ( arglist ) localslist BEGIN statementBlock ; . END
    (30) statementBlock -> statementBlock ; . statement
    (33) statement -> . WHILE relation DO statement
    (34) statement -> . ifthen
    (35) statement -> . ifthenelse
    (36) statement -> . location ASIGN expression
    (37) statement -> . inOutExpr
    (38) statement -> . RETURN expression
    (39) statement -> . RETURN
    (40) statement -> . functionCall
    (41) statement -> . SKIP
    (42) statement -> . BREAK
    (43) statement -> . BEGIN statementBlock END
    (44) statement -> . BEGIN END
    (45) ifthen -> . IF relation THEN statement
    (46) ifthenelse -> . IF relation THEN statement ELSE statement
    (47) ifthenelse -> . IF relation statement ELSE statement
    (56) location -> . ID
    (57) location -> . ID [ expression ]
    (53) inOutExpr -> . PRINT ( STRING )
    (54) inOutExpr -> . WRITE ( expression )
    (55) inOutExpr -> . READ ( location )
    (48) functionCall -> . ID ( paramslistop )

    END             shift and go to state 158
    WHILE           shift and go to state 47
    RETURN          shift and go to state 43
    SKIP            shift and go to state 53
    BREAK           shift and go to state 58
    BEGIN           shift and go to state 49
    IF              shift and go to state 57
    ID              shift and go to state 56
    PRINT           shift and go to state 46
    WRITE           shift and go to state 54
    READ            shift and go to state 44

    ifthenelse                     shift and go to state 52
    inOutExpr                      shift and go to state 45
    location                       shift and go to state 50
    statement                      shift and go to state 94
    functionCall                   shift and go to state 55
    ifthen                         shift and go to state 48

state 131

    (5) function -> FUN ID ( arglist ) localslist BEGIN statementBlock END .

    ;               reduce using rule 5 (function -> FUN ID ( arglist ) localslist BEGIN statementBlock END .)
    ID              reduce using rule 5 (function -> FUN ID ( arglist ) localslist BEGIN statementBlock END .)
    FUN             reduce using rule 5 (function -> FUN ID ( arglist ) localslist BEGIN statementBlock END .)
    BEGIN           reduce using rule 5 (function -> FUN ID ( arglist ) localslist BEGIN statementBlock END .)
    $end            reduce using rule 5 (function -> FUN ID ( arglist ) localslist BEGIN statementBlock END .)


state 132

    (83) casting -> FLOAT ( expression . )
    (70) expression -> expression . + expression
    (71) expression -> expression . - expression
    (72) expression -> expression . * expression
    (73) expression -> expression . / expression

    )               shift and go to state 159
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103


state 133

    (76) expression -> ( expression ) .

    LT              reduce using rule 76 (expression -> ( expression ) .)
    LE              reduce using rule 76 (expression -> ( expression ) .)
    GT              reduce using rule 76 (expression -> ( expression ) .)
    GE              reduce using rule 76 (expression -> ( expression ) .)
    NE              reduce using rule 76 (expression -> ( expression ) .)
    EQUAL           reduce using rule 76 (expression -> ( expression ) .)
    +               reduce using rule 76 (expression -> ( expression ) .)
    -               reduce using rule 76 (expression -> ( expression ) .)
    *               reduce using rule 76 (expression -> ( expression ) .)
    /               reduce using rule 76 (expression -> ( expression ) .)
    ]               reduce using rule 76 (expression -> ( expression ) .)
    END             reduce using rule 76 (expression -> ( expression ) .)
    ;               reduce using rule 76 (expression -> ( expression ) .)
    WHILE           reduce using rule 76 (expression -> ( expression ) .)
    RETURN          reduce using rule 76 (expression -> ( expression ) .)
    SKIP            reduce using rule 76 (expression -> ( expression ) .)
    BREAK           reduce using rule 76 (expression -> ( expression ) .)
    BEGIN           reduce using rule 76 (expression -> ( expression ) .)
    IF              reduce using rule 76 (expression -> ( expression ) .)
    ID              reduce using rule 76 (expression -> ( expression ) .)
    PRINT           reduce using rule 76 (expression -> ( expression ) .)
    WRITE           reduce using rule 76 (expression -> ( expression ) .)
    READ            reduce using rule 76 (expression -> ( expression ) .)
    ELSE            reduce using rule 76 (expression -> ( expression ) .)
    )               reduce using rule 76 (expression -> ( expression ) .)
    ,               reduce using rule 76 (expression -> ( expression ) .)
    DO              reduce using rule 76 (expression -> ( expression ) .)
    OR              reduce using rule 76 (expression -> ( expression ) .)
    AND             reduce using rule 76 (expression -> ( expression ) .)
    THEN            reduce using rule 76 (expression -> ( expression ) .)


state 134

    (82) casting -> INT ( expression . )
    (70) expression -> expression . + expression
    (71) expression -> expression . - expression
    (72) expression -> expression . * expression
    (73) expression -> expression . / expression

    )               shift and go to state 160
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103


state 135

    (70) expression -> expression + expression .
    (70) expression -> expression . + expression
    (71) expression -> expression . - expression
    (72) expression -> expression . * expression
    (73) expression -> expression . / expression

    LT              reduce using rule 70 (expression -> expression + expression .)
    LE              reduce using rule 70 (expression -> expression + expression .)
    GT              reduce using rule 70 (expression -> expression + expression .)
    GE              reduce using rule 70 (expression -> expression + expression .)
    NE              reduce using rule 70 (expression -> expression + expression .)
    EQUAL           reduce using rule 70 (expression -> expression + expression .)
    +               reduce using rule 70 (expression -> expression + expression .)
    -               reduce using rule 70 (expression -> expression + expression .)
    ]               reduce using rule 70 (expression -> expression + expression .)
    END             reduce using rule 70 (expression -> expression + expression .)
    ;               reduce using rule 70 (expression -> expression + expression .)
    WHILE           reduce using rule 70 (expression -> expression + expression .)
    RETURN          reduce using rule 70 (expression -> expression + expression .)
    SKIP            reduce using rule 70 (expression -> expression + expression .)
    BREAK           reduce using rule 70 (expression -> expression + expression .)
    BEGIN           reduce using rule 70 (expression -> expression + expression .)
    IF              reduce using rule 70 (expression -> expression + expression .)
    ID              reduce using rule 70 (expression -> expression + expression .)
    PRINT           reduce using rule 70 (expression -> expression + expression .)
    WRITE           reduce using rule 70 (expression -> expression + expression .)
    READ            reduce using rule 70 (expression -> expression + expression .)
    ELSE            reduce using rule 70 (expression -> expression + expression .)
    )               reduce using rule 70 (expression -> expression + expression .)
    ,               reduce using rule 70 (expression -> expression + expression .)
    DO              reduce using rule 70 (expression -> expression + expression .)
    OR              reduce using rule 70 (expression -> expression + expression .)
    AND             reduce using rule 70 (expression -> expression + expression .)
    THEN            reduce using rule 70 (expression -> expression + expression .)
    *               shift and go to state 101
    /               shift and go to state 103

  ! *               [ reduce using rule 70 (expression -> expression + expression .) ]
  ! /               [ reduce using rule 70 (expression -> expression + expression .) ]
  ! +               [ shift and go to state 100 ]
  ! -               [ shift and go to state 102 ]


state 136

    (72) expression -> expression * expression .
    (70) expression -> expression . + expression
    (71) expression -> expression . - expression
    (72) expression -> expression . * expression
    (73) expression -> expression . / expression

    LT              reduce using rule 72 (expression -> expression * expression .)
    LE              reduce using rule 72 (expression -> expression * expression .)
    GT              reduce using rule 72 (expression -> expression * expression .)
    GE              reduce using rule 72 (expression -> expression * expression .)
    NE              reduce using rule 72 (expression -> expression * expression .)
    EQUAL           reduce using rule 72 (expression -> expression * expression .)
    +               reduce using rule 72 (expression -> expression * expression .)
    -               reduce using rule 72 (expression -> expression * expression .)
    *               reduce using rule 72 (expression -> expression * expression .)
    /               reduce using rule 72 (expression -> expression * expression .)
    ]               reduce using rule 72 (expression -> expression * expression .)
    END             reduce using rule 72 (expression -> expression * expression .)
    ;               reduce using rule 72 (expression -> expression * expression .)
    WHILE           reduce using rule 72 (expression -> expression * expression .)
    RETURN          reduce using rule 72 (expression -> expression * expression .)
    SKIP            reduce using rule 72 (expression -> expression * expression .)
    BREAK           reduce using rule 72 (expression -> expression * expression .)
    BEGIN           reduce using rule 72 (expression -> expression * expression .)
    IF              reduce using rule 72 (expression -> expression * expression .)
    ID              reduce using rule 72 (expression -> expression * expression .)
    PRINT           reduce using rule 72 (expression -> expression * expression .)
    WRITE           reduce using rule 72 (expression -> expression * expression .)
    READ            reduce using rule 72 (expression -> expression * expression .)
    ELSE            reduce using rule 72 (expression -> expression * expression .)
    )               reduce using rule 72 (expression -> expression * expression .)
    ,               reduce using rule 72 (expression -> expression * expression .)
    DO              reduce using rule 72 (expression -> expression * expression .)
    OR              reduce using rule 72 (expression -> expression * expression .)
    AND             reduce using rule 72 (expression -> expression * expression .)
    THEN            reduce using rule 72 (expression -> expression * expression .)

  ! +               [ shift and go to state 100 ]
  ! -               [ shift and go to state 102 ]
  ! *               [ shift and go to state 101 ]
  ! /               [ shift and go to state 103 ]


state 137

    (71) expression -> expression - expression .
    (70) expression -> expression . + expression
    (71) expression -> expression . - expression
    (72) expression -> expression . * expression
    (73) expression -> expression . / expression

    LT              reduce using rule 71 (expression -> expression - expression .)
    LE              reduce using rule 71 (expression -> expression - expression .)
    GT              reduce using rule 71 (expression -> expression - expression .)
    GE              reduce using rule 71 (expression -> expression - expression .)
    NE              reduce using rule 71 (expression -> expression - expression .)
    EQUAL           reduce using rule 71 (expression -> expression - expression .)
    +               reduce using rule 71 (expression -> expression - expression .)
    -               reduce using rule 71 (expression -> expression - expression .)
    ]               reduce using rule 71 (expression -> expression - expression .)
    END             reduce using rule 71 (expression -> expression - expression .)
    ;               reduce using rule 71 (expression -> expression - expression .)
    WHILE           reduce using rule 71 (expression -> expression - expression .)
    RETURN          reduce using rule 71 (expression -> expression - expression .)
    SKIP            reduce using rule 71 (expression -> expression - expression .)
    BREAK           reduce using rule 71 (expression -> expression - expression .)
    BEGIN           reduce using rule 71 (expression -> expression - expression .)
    IF              reduce using rule 71 (expression -> expression - expression .)
    ID              reduce using rule 71 (expression -> expression - expression .)
    PRINT           reduce using rule 71 (expression -> expression - expression .)
    WRITE           reduce using rule 71 (expression -> expression - expression .)
    READ            reduce using rule 71 (expression -> expression - expression .)
    ELSE            reduce using rule 71 (expression -> expression - expression .)
    )               reduce using rule 71 (expression -> expression - expression .)
    ,               reduce using rule 71 (expression -> expression - expression .)
    DO              reduce using rule 71 (expression -> expression - expression .)
    OR              reduce using rule 71 (expression -> expression - expression .)
    AND             reduce using rule 71 (expression -> expression - expression .)
    THEN            reduce using rule 71 (expression -> expression - expression .)
    *               shift and go to state 101
    /               shift and go to state 103

  ! *               [ reduce using rule 71 (expression -> expression - expression .) ]
  ! /               [ reduce using rule 71 (expression -> expression - expression .) ]
  ! +               [ shift and go to state 100 ]
  ! -               [ shift and go to state 102 ]


state 138

    (73) expression -> expression / expression .
    (70) expression -> expression . + expression
    (71) expression -> expression . - expression
    (72) expression -> expression . * expression
    (73) expression -> expression . / expression

    LT              reduce using rule 73 (expression -> expression / expression .)
    LE              reduce using rule 73 (expression -> expression / expression .)
    GT              reduce using rule 73 (expression -> expression / expression .)
    GE              reduce using rule 73 (expression -> expression / expression .)
    NE              reduce using rule 73 (expression -> expression / expression .)
    EQUAL           reduce using rule 73 (expression -> expression / expression .)
    +               reduce using rule 73 (expression -> expression / expression .)
    -               reduce using rule 73 (expression -> expression / expression .)
    *               reduce using rule 73 (expression -> expression / expression .)
    /               reduce using rule 73 (expression -> expression / expression .)
    ]               reduce using rule 73 (expression -> expression / expression .)
    END             reduce using rule 73 (expression -> expression / expression .)
    ;               reduce using rule 73 (expression -> expression / expression .)
    WHILE           reduce using rule 73 (expression -> expression / expression .)
    RETURN          reduce using rule 73 (expression -> expression / expression .)
    SKIP            reduce using rule 73 (expression -> expression / expression .)
    BREAK           reduce using rule 73 (expression -> expression / expression .)
    BEGIN           reduce using rule 73 (expression -> expression / expression .)
    IF              reduce using rule 73 (expression -> expression / expression .)
    ID              reduce using rule 73 (expression -> expression / expression .)
    PRINT           reduce using rule 73 (expression -> expression / expression .)
    WRITE           reduce using rule 73 (expression -> expression / expression .)
    READ            reduce using rule 73 (expression -> expression / expression .)
    ELSE            reduce using rule 73 (expression -> expression / expression .)
    )               reduce using rule 73 (expression -> expression / expression .)
    ,               reduce using rule 73 (expression -> expression / expression .)
    DO              reduce using rule 73 (expression -> expression / expression .)
    OR              reduce using rule 73 (expression -> expression / expression .)
    AND             reduce using rule 73 (expression -> expression / expression .)
    THEN            reduce using rule 73 (expression -> expression / expression .)

  ! +               [ shift and go to state 100 ]
  ! -               [ shift and go to state 102 ]
  ! *               [ shift and go to state 101 ]
  ! /               [ shift and go to state 103 ]


state 139

    (79) expression -> ID [ expression . ]
    (70) expression -> expression . + expression
    (71) expression -> expression . - expression
    (72) expression -> expression . * expression
    (73) expression -> expression . / expression

    ]               shift and go to state 161
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103


state 140

    (55) inOutExpr -> READ ( location ) .

    END             reduce using rule 55 (inOutExpr -> READ ( location ) .)
    ;               reduce using rule 55 (inOutExpr -> READ ( location ) .)
    WHILE           reduce using rule 55 (inOutExpr -> READ ( location ) .)
    RETURN          reduce using rule 55 (inOutExpr -> READ ( location ) .)
    SKIP            reduce using rule 55 (inOutExpr -> READ ( location ) .)
    BREAK           reduce using rule 55 (inOutExpr -> READ ( location ) .)
    BEGIN           reduce using rule 55 (inOutExpr -> READ ( location ) .)
    IF              reduce using rule 55 (inOutExpr -> READ ( location ) .)
    ID              reduce using rule 55 (inOutExpr -> READ ( location ) .)
    PRINT           reduce using rule 55 (inOutExpr -> READ ( location ) .)
    WRITE           reduce using rule 55 (inOutExpr -> READ ( location ) .)
    READ            reduce using rule 55 (inOutExpr -> READ ( location ) .)
    ELSE            reduce using rule 55 (inOutExpr -> READ ( location ) .)


state 141

    (53) inOutExpr -> PRINT ( STRING ) .

    END             reduce using rule 53 (inOutExpr -> PRINT ( STRING ) .)
    ;               reduce using rule 53 (inOutExpr -> PRINT ( STRING ) .)
    WHILE           reduce using rule 53 (inOutExpr -> PRINT ( STRING ) .)
    RETURN          reduce using rule 53 (inOutExpr -> PRINT ( STRING ) .)
    SKIP            reduce using rule 53 (inOutExpr -> PRINT ( STRING ) .)
    BREAK           reduce using rule 53 (inOutExpr -> PRINT ( STRING ) .)
    BEGIN           reduce using rule 53 (inOutExpr -> PRINT ( STRING ) .)
    IF              reduce using rule 53 (inOutExpr -> PRINT ( STRING ) .)
    ID              reduce using rule 53 (inOutExpr -> PRINT ( STRING ) .)
    PRINT           reduce using rule 53 (inOutExpr -> PRINT ( STRING ) .)
    WRITE           reduce using rule 53 (inOutExpr -> PRINT ( STRING ) .)
    READ            reduce using rule 53 (inOutExpr -> PRINT ( STRING ) .)
    ELSE            reduce using rule 53 (inOutExpr -> PRINT ( STRING ) .)


state 142

    (59) relation -> relation AND relation .
    (58) relation -> relation . OR relation
    (59) relation -> relation . AND relation

    THEN            reduce using rule 59 (relation -> relation AND relation .)
    OR              reduce using rule 59 (relation -> relation AND relation .)
    AND             reduce using rule 59 (relation -> relation AND relation .)
    WHILE           reduce using rule 59 (relation -> relation AND relation .)
    RETURN          reduce using rule 59 (relation -> relation AND relation .)
    SKIP            reduce using rule 59 (relation -> relation AND relation .)
    BREAK           reduce using rule 59 (relation -> relation AND relation .)
    BEGIN           reduce using rule 59 (relation -> relation AND relation .)
    IF              reduce using rule 59 (relation -> relation AND relation .)
    ID              reduce using rule 59 (relation -> relation AND relation .)
    PRINT           reduce using rule 59 (relation -> relation AND relation .)
    WRITE           reduce using rule 59 (relation -> relation AND relation .)
    READ            reduce using rule 59 (relation -> relation AND relation .)
    DO              reduce using rule 59 (relation -> relation AND relation .)
    )               reduce using rule 59 (relation -> relation AND relation .)

  ! OR              [ shift and go to state 110 ]
  ! AND             [ shift and go to state 108 ]


state 143

    (33) statement -> WHILE relation DO statement .

    END             reduce using rule 33 (statement -> WHILE relation DO statement .)
    ;               reduce using rule 33 (statement -> WHILE relation DO statement .)
    WHILE           reduce using rule 33 (statement -> WHILE relation DO statement .)
    RETURN          reduce using rule 33 (statement -> WHILE relation DO statement .)
    SKIP            reduce using rule 33 (statement -> WHILE relation DO statement .)
    BREAK           reduce using rule 33 (statement -> WHILE relation DO statement .)
    BEGIN           reduce using rule 33 (statement -> WHILE relation DO statement .)
    IF              reduce using rule 33 (statement -> WHILE relation DO statement .)
    ID              reduce using rule 33 (statement -> WHILE relation DO statement .)
    PRINT           reduce using rule 33 (statement -> WHILE relation DO statement .)
    WRITE           reduce using rule 33 (statement -> WHILE relation DO statement .)
    READ            reduce using rule 33 (statement -> WHILE relation DO statement .)
    ELSE            reduce using rule 33 (statement -> WHILE relation DO statement .)


state 144

    (58) relation -> relation OR relation .
    (58) relation -> relation . OR relation
    (59) relation -> relation . AND relation

    THEN            reduce using rule 58 (relation -> relation OR relation .)
    OR              reduce using rule 58 (relation -> relation OR relation .)
    WHILE           reduce using rule 58 (relation -> relation OR relation .)
    RETURN          reduce using rule 58 (relation -> relation OR relation .)
    SKIP            reduce using rule 58 (relation -> relation OR relation .)
    BREAK           reduce using rule 58 (relation -> relation OR relation .)
    BEGIN           reduce using rule 58 (relation -> relation OR relation .)
    IF              reduce using rule 58 (relation -> relation OR relation .)
    ID              reduce using rule 58 (relation -> relation OR relation .)
    PRINT           reduce using rule 58 (relation -> relation OR relation .)
    WRITE           reduce using rule 58 (relation -> relation OR relation .)
    READ            reduce using rule 58 (relation -> relation OR relation .)
    DO              reduce using rule 58 (relation -> relation OR relation .)
    )               reduce using rule 58 (relation -> relation OR relation .)
    AND             shift and go to state 108

  ! AND             [ reduce using rule 58 (relation -> relation OR relation .) ]
  ! OR              [ shift and go to state 110 ]


state 145

    (61) relation -> ( relation ) .

    THEN            reduce using rule 61 (relation -> ( relation ) .)
    OR              reduce using rule 61 (relation -> ( relation ) .)
    AND             reduce using rule 61 (relation -> ( relation ) .)
    WHILE           reduce using rule 61 (relation -> ( relation ) .)
    RETURN          reduce using rule 61 (relation -> ( relation ) .)
    SKIP            reduce using rule 61 (relation -> ( relation ) .)
    BREAK           reduce using rule 61 (relation -> ( relation ) .)
    BEGIN           reduce using rule 61 (relation -> ( relation ) .)
    IF              reduce using rule 61 (relation -> ( relation ) .)
    ID              reduce using rule 61 (relation -> ( relation ) .)
    PRINT           reduce using rule 61 (relation -> ( relation ) .)
    WRITE           reduce using rule 61 (relation -> ( relation ) .)
    READ            reduce using rule 61 (relation -> ( relation ) .)
    DO              reduce using rule 61 (relation -> ( relation ) .)
    )               reduce using rule 61 (relation -> ( relation ) .)


state 146

    (63) relation -> expression LE expression .
    (70) expression -> expression . + expression
    (71) expression -> expression . - expression
    (72) expression -> expression . * expression
    (73) expression -> expression . / expression

    THEN            reduce using rule 63 (relation -> expression LE expression .)
    OR              reduce using rule 63 (relation -> expression LE expression .)
    AND             reduce using rule 63 (relation -> expression LE expression .)
    WHILE           reduce using rule 63 (relation -> expression LE expression .)
    RETURN          reduce using rule 63 (relation -> expression LE expression .)
    SKIP            reduce using rule 63 (relation -> expression LE expression .)
    BREAK           reduce using rule 63 (relation -> expression LE expression .)
    BEGIN           reduce using rule 63 (relation -> expression LE expression .)
    IF              reduce using rule 63 (relation -> expression LE expression .)
    ID              reduce using rule 63 (relation -> expression LE expression .)
    PRINT           reduce using rule 63 (relation -> expression LE expression .)
    WRITE           reduce using rule 63 (relation -> expression LE expression .)
    READ            reduce using rule 63 (relation -> expression LE expression .)
    DO              reduce using rule 63 (relation -> expression LE expression .)
    )               reduce using rule 63 (relation -> expression LE expression .)
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103


state 147

    (67) relation -> expression EQUAL expression .
    (70) expression -> expression . + expression
    (71) expression -> expression . - expression
    (72) expression -> expression . * expression
    (73) expression -> expression . / expression

    THEN            reduce using rule 67 (relation -> expression EQUAL expression .)
    OR              reduce using rule 67 (relation -> expression EQUAL expression .)
    AND             reduce using rule 67 (relation -> expression EQUAL expression .)
    WHILE           reduce using rule 67 (relation -> expression EQUAL expression .)
    RETURN          reduce using rule 67 (relation -> expression EQUAL expression .)
    SKIP            reduce using rule 67 (relation -> expression EQUAL expression .)
    BREAK           reduce using rule 67 (relation -> expression EQUAL expression .)
    BEGIN           reduce using rule 67 (relation -> expression EQUAL expression .)
    IF              reduce using rule 67 (relation -> expression EQUAL expression .)
    ID              reduce using rule 67 (relation -> expression EQUAL expression .)
    PRINT           reduce using rule 67 (relation -> expression EQUAL expression .)
    WRITE           reduce using rule 67 (relation -> expression EQUAL expression .)
    READ            reduce using rule 67 (relation -> expression EQUAL expression .)
    DO              reduce using rule 67 (relation -> expression EQUAL expression .)
    )               reduce using rule 67 (relation -> expression EQUAL expression .)
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103


state 148

    (65) relation -> expression GE expression .
    (70) expression -> expression . + expression
    (71) expression -> expression . - expression
    (72) expression -> expression . * expression
    (73) expression -> expression . / expression

    THEN            reduce using rule 65 (relation -> expression GE expression .)
    OR              reduce using rule 65 (relation -> expression GE expression .)
    AND             reduce using rule 65 (relation -> expression GE expression .)
    WHILE           reduce using rule 65 (relation -> expression GE expression .)
    RETURN          reduce using rule 65 (relation -> expression GE expression .)
    SKIP            reduce using rule 65 (relation -> expression GE expression .)
    BREAK           reduce using rule 65 (relation -> expression GE expression .)
    BEGIN           reduce using rule 65 (relation -> expression GE expression .)
    IF              reduce using rule 65 (relation -> expression GE expression .)
    ID              reduce using rule 65 (relation -> expression GE expression .)
    PRINT           reduce using rule 65 (relation -> expression GE expression .)
    WRITE           reduce using rule 65 (relation -> expression GE expression .)
    READ            reduce using rule 65 (relation -> expression GE expression .)
    DO              reduce using rule 65 (relation -> expression GE expression .)
    )               reduce using rule 65 (relation -> expression GE expression .)
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103


state 149

    (66) relation -> expression NE expression .
    (70) expression -> expression . + expression
    (71) expression -> expression . - expression
    (72) expression -> expression . * expression
    (73) expression -> expression . / expression

    THEN            reduce using rule 66 (relation -> expression NE expression .)
    OR              reduce using rule 66 (relation -> expression NE expression .)
    AND             reduce using rule 66 (relation -> expression NE expression .)
    WHILE           reduce using rule 66 (relation -> expression NE expression .)
    RETURN          reduce using rule 66 (relation -> expression NE expression .)
    SKIP            reduce using rule 66 (relation -> expression NE expression .)
    BREAK           reduce using rule 66 (relation -> expression NE expression .)
    BEGIN           reduce using rule 66 (relation -> expression NE expression .)
    IF              reduce using rule 66 (relation -> expression NE expression .)
    ID              reduce using rule 66 (relation -> expression NE expression .)
    PRINT           reduce using rule 66 (relation -> expression NE expression .)
    WRITE           reduce using rule 66 (relation -> expression NE expression .)
    READ            reduce using rule 66 (relation -> expression NE expression .)
    DO              reduce using rule 66 (relation -> expression NE expression .)
    )               reduce using rule 66 (relation -> expression NE expression .)
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103


state 150

    (62) relation -> expression LT expression .
    (70) expression -> expression . + expression
    (71) expression -> expression . - expression
    (72) expression -> expression . * expression
    (73) expression -> expression . / expression

    THEN            reduce using rule 62 (relation -> expression LT expression .)
    OR              reduce using rule 62 (relation -> expression LT expression .)
    AND             reduce using rule 62 (relation -> expression LT expression .)
    WHILE           reduce using rule 62 (relation -> expression LT expression .)
    RETURN          reduce using rule 62 (relation -> expression LT expression .)
    SKIP            reduce using rule 62 (relation -> expression LT expression .)
    BREAK           reduce using rule 62 (relation -> expression LT expression .)
    BEGIN           reduce using rule 62 (relation -> expression LT expression .)
    IF              reduce using rule 62 (relation -> expression LT expression .)
    ID              reduce using rule 62 (relation -> expression LT expression .)
    PRINT           reduce using rule 62 (relation -> expression LT expression .)
    WRITE           reduce using rule 62 (relation -> expression LT expression .)
    READ            reduce using rule 62 (relation -> expression LT expression .)
    DO              reduce using rule 62 (relation -> expression LT expression .)
    )               reduce using rule 62 (relation -> expression LT expression .)
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103


state 151

    (64) relation -> expression GT expression .
    (70) expression -> expression . + expression
    (71) expression -> expression . - expression
    (72) expression -> expression . * expression
    (73) expression -> expression . / expression

    THEN            reduce using rule 64 (relation -> expression GT expression .)
    OR              reduce using rule 64 (relation -> expression GT expression .)
    AND             reduce using rule 64 (relation -> expression GT expression .)
    WHILE           reduce using rule 64 (relation -> expression GT expression .)
    RETURN          reduce using rule 64 (relation -> expression GT expression .)
    SKIP            reduce using rule 64 (relation -> expression GT expression .)
    BREAK           reduce using rule 64 (relation -> expression GT expression .)
    BEGIN           reduce using rule 64 (relation -> expression GT expression .)
    IF              reduce using rule 64 (relation -> expression GT expression .)
    ID              reduce using rule 64 (relation -> expression GT expression .)
    PRINT           reduce using rule 64 (relation -> expression GT expression .)
    WRITE           reduce using rule 64 (relation -> expression GT expression .)
    READ            reduce using rule 64 (relation -> expression GT expression .)
    DO              reduce using rule 64 (relation -> expression GT expression .)
    )               reduce using rule 64 (relation -> expression GT expression .)
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103


state 152

    (54) inOutExpr -> WRITE ( expression ) .

    END             reduce using rule 54 (inOutExpr -> WRITE ( expression ) .)
    ;               reduce using rule 54 (inOutExpr -> WRITE ( expression ) .)
    WHILE           reduce using rule 54 (inOutExpr -> WRITE ( expression ) .)
    RETURN          reduce using rule 54 (inOutExpr -> WRITE ( expression ) .)
    SKIP            reduce using rule 54 (inOutExpr -> WRITE ( expression ) .)
    BREAK           reduce using rule 54 (inOutExpr -> WRITE ( expression ) .)
    BEGIN           reduce using rule 54 (inOutExpr -> WRITE ( expression ) .)
    IF              reduce using rule 54 (inOutExpr -> WRITE ( expression ) .)
    ID              reduce using rule 54 (inOutExpr -> WRITE ( expression ) .)
    PRINT           reduce using rule 54 (inOutExpr -> WRITE ( expression ) .)
    WRITE           reduce using rule 54 (inOutExpr -> WRITE ( expression ) .)
    READ            reduce using rule 54 (inOutExpr -> WRITE ( expression ) .)
    ELSE            reduce using rule 54 (inOutExpr -> WRITE ( expression ) .)


state 153

    (48) functionCall -> ID ( paramslistop ) .

    +               reduce using rule 48 (functionCall -> ID ( paramslistop ) .)
    -               reduce using rule 48 (functionCall -> ID ( paramslistop ) .)
    *               reduce using rule 48 (functionCall -> ID ( paramslistop ) .)
    /               reduce using rule 48 (functionCall -> ID ( paramslistop ) .)
    DO              reduce using rule 48 (functionCall -> ID ( paramslistop ) .)
    OR              reduce using rule 48 (functionCall -> ID ( paramslistop ) .)
    AND             reduce using rule 48 (functionCall -> ID ( paramslistop ) .)
    THEN            reduce using rule 48 (functionCall -> ID ( paramslistop ) .)
    WHILE           reduce using rule 48 (functionCall -> ID ( paramslistop ) .)
    RETURN          reduce using rule 48 (functionCall -> ID ( paramslistop ) .)
    SKIP            reduce using rule 48 (functionCall -> ID ( paramslistop ) .)
    BREAK           reduce using rule 48 (functionCall -> ID ( paramslistop ) .)
    BEGIN           reduce using rule 48 (functionCall -> ID ( paramslistop ) .)
    IF              reduce using rule 48 (functionCall -> ID ( paramslistop ) .)
    ID              reduce using rule 48 (functionCall -> ID ( paramslistop ) .)
    PRINT           reduce using rule 48 (functionCall -> ID ( paramslistop ) .)
    WRITE           reduce using rule 48 (functionCall -> ID ( paramslistop ) .)
    READ            reduce using rule 48 (functionCall -> ID ( paramslistop ) .)
    )               reduce using rule 48 (functionCall -> ID ( paramslistop ) .)
    ,               reduce using rule 48 (functionCall -> ID ( paramslistop ) .)
    END             reduce using rule 48 (functionCall -> ID ( paramslistop ) .)
    ;               reduce using rule 48 (functionCall -> ID ( paramslistop ) .)
    ELSE            reduce using rule 48 (functionCall -> ID ( paramslistop ) .)
    ]               reduce using rule 48 (functionCall -> ID ( paramslistop ) .)
    LT              reduce using rule 48 (functionCall -> ID ( paramslistop ) .)
    LE              reduce using rule 48 (functionCall -> ID ( paramslistop ) .)
    GT              reduce using rule 48 (functionCall -> ID ( paramslistop ) .)
    GE              reduce using rule 48 (functionCall -> ID ( paramslistop ) .)
    NE              reduce using rule 48 (functionCall -> ID ( paramslistop ) .)
    EQUAL           reduce using rule 48 (functionCall -> ID ( paramslistop ) .)


state 154

    (51) paramList -> paramList , . expression
    (70) expression -> . expression + expression
    (71) expression -> . expression - expression
    (72) expression -> . expression * expression
    (73) expression -> . expression / expression
    (74) expression -> . - expression
    (75) expression -> . + expression
    (76) expression -> . ( expression )
    (77) expression -> . ID
    (78) expression -> . number
    (79) expression -> . ID [ expression ]
    (80) expression -> . casting
    (81) expression -> . functionCall
    (84) number -> . INTEGER
    (85) number -> . FLOATNUM
    (82) casting -> . INT ( expression )
    (83) casting -> . FLOAT ( expression )
    (48) functionCall -> . ID ( paramslistop )

    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 67
    ID              shift and go to state 77
    INTEGER         shift and go to state 74
    FLOATNUM        shift and go to state 73
    INT             shift and go to state 71
    FLOAT           shift and go to state 66

    casting                        shift and go to state 75
    number                         shift and go to state 70
    functionCall                   shift and go to state 72
    expression                     shift and go to state 162

state 155

    (57) location -> ID [ expression ] .

    ASIGN           reduce using rule 57 (location -> ID [ expression ] .)
    )               reduce using rule 57 (location -> ID [ expression ] .)


state 156

    (45) ifthen -> IF relation THEN statement .
    (46) ifthenelse -> IF relation THEN statement . ELSE statement

    END             reduce using rule 45 (ifthen -> IF relation THEN statement .)
    ;               reduce using rule 45 (ifthen -> IF relation THEN statement .)
    WHILE           reduce using rule 45 (ifthen -> IF relation THEN statement .)
    RETURN          reduce using rule 45 (ifthen -> IF relation THEN statement .)
    SKIP            reduce using rule 45 (ifthen -> IF relation THEN statement .)
    BREAK           reduce using rule 45 (ifthen -> IF relation THEN statement .)
    BEGIN           reduce using rule 45 (ifthen -> IF relation THEN statement .)
    IF              reduce using rule 45 (ifthen -> IF relation THEN statement .)
    ID              reduce using rule 45 (ifthen -> IF relation THEN statement .)
    PRINT           reduce using rule 45 (ifthen -> IF relation THEN statement .)
    WRITE           reduce using rule 45 (ifthen -> IF relation THEN statement .)
    READ            reduce using rule 45 (ifthen -> IF relation THEN statement .)
    ELSE            shift and go to state 163

  ! ELSE            [ reduce using rule 45 (ifthen -> IF relation THEN statement .) ]


state 157

    (47) ifthenelse -> IF relation statement ELSE . statement
    (33) statement -> . WHILE relation DO statement
    (34) statement -> . ifthen
    (35) statement -> . ifthenelse
    (36) statement -> . location ASIGN expression
    (37) statement -> . inOutExpr
    (38) statement -> . RETURN expression
    (39) statement -> . RETURN
    (40) statement -> . functionCall
    (41) statement -> . SKIP
    (42) statement -> . BREAK
    (43) statement -> . BEGIN statementBlock END
    (44) statement -> . BEGIN END
    (45) ifthen -> . IF relation THEN statement
    (46) ifthenelse -> . IF relation THEN statement ELSE statement
    (47) ifthenelse -> . IF relation statement ELSE statement
    (56) location -> . ID
    (57) location -> . ID [ expression ]
    (53) inOutExpr -> . PRINT ( STRING )
    (54) inOutExpr -> . WRITE ( expression )
    (55) inOutExpr -> . READ ( location )
    (48) functionCall -> . ID ( paramslistop )

    WHILE           shift and go to state 47
    RETURN          shift and go to state 43
    SKIP            shift and go to state 53
    BREAK           shift and go to state 58
    BEGIN           shift and go to state 49
    IF              shift and go to state 57
    ID              shift and go to state 56
    PRINT           shift and go to state 46
    WRITE           shift and go to state 54
    READ            shift and go to state 44

    ifthenelse                     shift and go to state 52
    inOutExpr                      shift and go to state 45
    location                       shift and go to state 50
    statement                      shift and go to state 164
    functionCall                   shift and go to state 55
    ifthen                         shift and go to state 48

state 158

    (7) function -> FUN ID ( arglist ) localslist BEGIN statementBlock ; END .

    ;               reduce using rule 7 (function -> FUN ID ( arglist ) localslist BEGIN statementBlock ; END .)
    ID              reduce using rule 7 (function -> FUN ID ( arglist ) localslist BEGIN statementBlock ; END .)
    FUN             reduce using rule 7 (function -> FUN ID ( arglist ) localslist BEGIN statementBlock ; END .)
    BEGIN           reduce using rule 7 (function -> FUN ID ( arglist ) localslist BEGIN statementBlock ; END .)
    $end            reduce using rule 7 (function -> FUN ID ( arglist ) localslist BEGIN statementBlock ; END .)


state 159

    (83) casting -> FLOAT ( expression ) .

    +               reduce using rule 83 (casting -> FLOAT ( expression ) .)
    -               reduce using rule 83 (casting -> FLOAT ( expression ) .)
    *               reduce using rule 83 (casting -> FLOAT ( expression ) .)
    /               reduce using rule 83 (casting -> FLOAT ( expression ) .)
    ,               reduce using rule 83 (casting -> FLOAT ( expression ) .)
    )               reduce using rule 83 (casting -> FLOAT ( expression ) .)
    LT              reduce using rule 83 (casting -> FLOAT ( expression ) .)
    LE              reduce using rule 83 (casting -> FLOAT ( expression ) .)
    GT              reduce using rule 83 (casting -> FLOAT ( expression ) .)
    GE              reduce using rule 83 (casting -> FLOAT ( expression ) .)
    NE              reduce using rule 83 (casting -> FLOAT ( expression ) .)
    EQUAL           reduce using rule 83 (casting -> FLOAT ( expression ) .)
    ]               reduce using rule 83 (casting -> FLOAT ( expression ) .)
    DO              reduce using rule 83 (casting -> FLOAT ( expression ) .)
    OR              reduce using rule 83 (casting -> FLOAT ( expression ) .)
    AND             reduce using rule 83 (casting -> FLOAT ( expression ) .)
    THEN            reduce using rule 83 (casting -> FLOAT ( expression ) .)
    WHILE           reduce using rule 83 (casting -> FLOAT ( expression ) .)
    RETURN          reduce using rule 83 (casting -> FLOAT ( expression ) .)
    SKIP            reduce using rule 83 (casting -> FLOAT ( expression ) .)
    BREAK           reduce using rule 83 (casting -> FLOAT ( expression ) .)
    BEGIN           reduce using rule 83 (casting -> FLOAT ( expression ) .)
    IF              reduce using rule 83 (casting -> FLOAT ( expression ) .)
    ID              reduce using rule 83 (casting -> FLOAT ( expression ) .)
    PRINT           reduce using rule 83 (casting -> FLOAT ( expression ) .)
    WRITE           reduce using rule 83 (casting -> FLOAT ( expression ) .)
    READ            reduce using rule 83 (casting -> FLOAT ( expression ) .)
    END             reduce using rule 83 (casting -> FLOAT ( expression ) .)
    ;               reduce using rule 83 (casting -> FLOAT ( expression ) .)
    ELSE            reduce using rule 83 (casting -> FLOAT ( expression ) .)


state 160

    (82) casting -> INT ( expression ) .

    +               reduce using rule 82 (casting -> INT ( expression ) .)
    -               reduce using rule 82 (casting -> INT ( expression ) .)
    *               reduce using rule 82 (casting -> INT ( expression ) .)
    /               reduce using rule 82 (casting -> INT ( expression ) .)
    ,               reduce using rule 82 (casting -> INT ( expression ) .)
    )               reduce using rule 82 (casting -> INT ( expression ) .)
    LT              reduce using rule 82 (casting -> INT ( expression ) .)
    LE              reduce using rule 82 (casting -> INT ( expression ) .)
    GT              reduce using rule 82 (casting -> INT ( expression ) .)
    GE              reduce using rule 82 (casting -> INT ( expression ) .)
    NE              reduce using rule 82 (casting -> INT ( expression ) .)
    EQUAL           reduce using rule 82 (casting -> INT ( expression ) .)
    ]               reduce using rule 82 (casting -> INT ( expression ) .)
    DO              reduce using rule 82 (casting -> INT ( expression ) .)
    OR              reduce using rule 82 (casting -> INT ( expression ) .)
    AND             reduce using rule 82 (casting -> INT ( expression ) .)
    THEN            reduce using rule 82 (casting -> INT ( expression ) .)
    WHILE           reduce using rule 82 (casting -> INT ( expression ) .)
    RETURN          reduce using rule 82 (casting -> INT ( expression ) .)
    SKIP            reduce using rule 82 (casting -> INT ( expression ) .)
    BREAK           reduce using rule 82 (casting -> INT ( expression ) .)
    BEGIN           reduce using rule 82 (casting -> INT ( expression ) .)
    IF              reduce using rule 82 (casting -> INT ( expression ) .)
    ID              reduce using rule 82 (casting -> INT ( expression ) .)
    PRINT           reduce using rule 82 (casting -> INT ( expression ) .)
    WRITE           reduce using rule 82 (casting -> INT ( expression ) .)
    READ            reduce using rule 82 (casting -> INT ( expression ) .)
    END             reduce using rule 82 (casting -> INT ( expression ) .)
    ;               reduce using rule 82 (casting -> INT ( expression ) .)
    ELSE            reduce using rule 82 (casting -> INT ( expression ) .)


state 161

    (79) expression -> ID [ expression ] .

    LT              reduce using rule 79 (expression -> ID [ expression ] .)
    LE              reduce using rule 79 (expression -> ID [ expression ] .)
    GT              reduce using rule 79 (expression -> ID [ expression ] .)
    GE              reduce using rule 79 (expression -> ID [ expression ] .)
    NE              reduce using rule 79 (expression -> ID [ expression ] .)
    EQUAL           reduce using rule 79 (expression -> ID [ expression ] .)
    +               reduce using rule 79 (expression -> ID [ expression ] .)
    -               reduce using rule 79 (expression -> ID [ expression ] .)
    *               reduce using rule 79 (expression -> ID [ expression ] .)
    /               reduce using rule 79 (expression -> ID [ expression ] .)
    ]               reduce using rule 79 (expression -> ID [ expression ] .)
    END             reduce using rule 79 (expression -> ID [ expression ] .)
    ;               reduce using rule 79 (expression -> ID [ expression ] .)
    WHILE           reduce using rule 79 (expression -> ID [ expression ] .)
    RETURN          reduce using rule 79 (expression -> ID [ expression ] .)
    SKIP            reduce using rule 79 (expression -> ID [ expression ] .)
    BREAK           reduce using rule 79 (expression -> ID [ expression ] .)
    BEGIN           reduce using rule 79 (expression -> ID [ expression ] .)
    IF              reduce using rule 79 (expression -> ID [ expression ] .)
    ID              reduce using rule 79 (expression -> ID [ expression ] .)
    PRINT           reduce using rule 79 (expression -> ID [ expression ] .)
    WRITE           reduce using rule 79 (expression -> ID [ expression ] .)
    READ            reduce using rule 79 (expression -> ID [ expression ] .)
    ELSE            reduce using rule 79 (expression -> ID [ expression ] .)
    )               reduce using rule 79 (expression -> ID [ expression ] .)
    ,               reduce using rule 79 (expression -> ID [ expression ] .)
    DO              reduce using rule 79 (expression -> ID [ expression ] .)
    OR              reduce using rule 79 (expression -> ID [ expression ] .)
    AND             reduce using rule 79 (expression -> ID [ expression ] .)
    THEN            reduce using rule 79 (expression -> ID [ expression ] .)


state 162

    (51) paramList -> paramList , expression .
    (70) expression -> expression . + expression
    (71) expression -> expression . - expression
    (72) expression -> expression . * expression
    (73) expression -> expression . / expression

    ,               reduce using rule 51 (paramList -> paramList , expression .)
    )               reduce using rule 51 (paramList -> paramList , expression .)
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103


state 163

    (46) ifthenelse -> IF relation THEN statement ELSE . statement
    (33) statement -> . WHILE relation DO statement
    (34) statement -> . ifthen
    (35) statement -> . ifthenelse
    (36) statement -> . location ASIGN expression
    (37) statement -> . inOutExpr
    (38) statement -> . RETURN expression
    (39) statement -> . RETURN
    (40) statement -> . functionCall
    (41) statement -> . SKIP
    (42) statement -> . BREAK
    (43) statement -> . BEGIN statementBlock END
    (44) statement -> . BEGIN END
    (45) ifthen -> . IF relation THEN statement
    (46) ifthenelse -> . IF relation THEN statement ELSE statement
    (47) ifthenelse -> . IF relation statement ELSE statement
    (56) location -> . ID
    (57) location -> . ID [ expression ]
    (53) inOutExpr -> . PRINT ( STRING )
    (54) inOutExpr -> . WRITE ( expression )
    (55) inOutExpr -> . READ ( location )
    (48) functionCall -> . ID ( paramslistop )

    WHILE           shift and go to state 47
    RETURN          shift and go to state 43
    SKIP            shift and go to state 53
    BREAK           shift and go to state 58
    BEGIN           shift and go to state 49
    IF              shift and go to state 57
    ID              shift and go to state 56
    PRINT           shift and go to state 46
    WRITE           shift and go to state 54
    READ            shift and go to state 44

    ifthenelse                     shift and go to state 52
    inOutExpr                      shift and go to state 45
    location                       shift and go to state 50
    statement                      shift and go to state 165
    functionCall                   shift and go to state 55
    ifthen                         shift and go to state 48

state 164

    (47) ifthenelse -> IF relation statement ELSE statement .

    END             reduce using rule 47 (ifthenelse -> IF relation statement ELSE statement .)
    ;               reduce using rule 47 (ifthenelse -> IF relation statement ELSE statement .)
    WHILE           reduce using rule 47 (ifthenelse -> IF relation statement ELSE statement .)
    RETURN          reduce using rule 47 (ifthenelse -> IF relation statement ELSE statement .)
    SKIP            reduce using rule 47 (ifthenelse -> IF relation statement ELSE statement .)
    BREAK           reduce using rule 47 (ifthenelse -> IF relation statement ELSE statement .)
    BEGIN           reduce using rule 47 (ifthenelse -> IF relation statement ELSE statement .)
    IF              reduce using rule 47 (ifthenelse -> IF relation statement ELSE statement .)
    ID              reduce using rule 47 (ifthenelse -> IF relation statement ELSE statement .)
    PRINT           reduce using rule 47 (ifthenelse -> IF relation statement ELSE statement .)
    WRITE           reduce using rule 47 (ifthenelse -> IF relation statement ELSE statement .)
    READ            reduce using rule 47 (ifthenelse -> IF relation statement ELSE statement .)
    ELSE            reduce using rule 47 (ifthenelse -> IF relation statement ELSE statement .)


state 165

    (46) ifthenelse -> IF relation THEN statement ELSE statement .

    END             reduce using rule 46 (ifthenelse -> IF relation THEN statement ELSE statement .)
    ;               reduce using rule 46 (ifthenelse -> IF relation THEN statement ELSE statement .)
    WHILE           reduce using rule 46 (ifthenelse -> IF relation THEN statement ELSE statement .)
    RETURN          reduce using rule 46 (ifthenelse -> IF relation THEN statement ELSE statement .)
    SKIP            reduce using rule 46 (ifthenelse -> IF relation THEN statement ELSE statement .)
    BREAK           reduce using rule 46 (ifthenelse -> IF relation THEN statement ELSE statement .)
    BEGIN           reduce using rule 46 (ifthenelse -> IF relation THEN statement ELSE statement .)
    IF              reduce using rule 46 (ifthenelse -> IF relation THEN statement ELSE statement .)
    ID              reduce using rule 46 (ifthenelse -> IF relation THEN statement ELSE statement .)
    PRINT           reduce using rule 46 (ifthenelse -> IF relation THEN statement ELSE statement .)
    WRITE           reduce using rule 46 (ifthenelse -> IF relation THEN statement ELSE statement .)
    READ            reduce using rule 46 (ifthenelse -> IF relation THEN statement ELSE statement .)
    ELSE            reduce using rule 46 (ifthenelse -> IF relation THEN statement ELSE statement .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 43 resolved as shift
